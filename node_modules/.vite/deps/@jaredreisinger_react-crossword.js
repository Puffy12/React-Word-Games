import {
  init_emotion_is_prop_valid_esm,
  isPropValid,
  require_shallowequal
} from "./chunk-MZJIQAV3.js";
import {
  require_jsx_runtime
} from "./chunk-ZXFJB5PS.js";
import {
  require_prop_types
} from "./chunk-46VXW76L.js";
import {
  require_react
} from "./chunk-VMZ364YV.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-CEQRFMJQ.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/@emotion/stylis/dist/stylis.browser.esm.js
function stylis_min(W2) {
  function M2(d2, c2, e2, h, a2) {
    for (var m2 = 0, b2 = 0, v2 = 0, n2 = 0, q2, g2, x2 = 0, K2 = 0, k2, u2 = k2 = q2 = 0, l2 = 0, r2 = 0, I2 = 0, t2 = 0, B3 = e2.length, J2 = B3 - 1, y2, f = "", p = "", F3 = "", G3 = "", C2; l2 < B3; ) {
      g2 = e2.charCodeAt(l2);
      l2 === J2 && 0 !== b2 + n2 + v2 + m2 && (0 !== b2 && (g2 = 47 === b2 ? 10 : 47), n2 = v2 = m2 = 0, B3++, J2++);
      if (0 === b2 + n2 + v2 + m2) {
        if (l2 === J2 && (0 < r2 && (f = f.replace(N2, "")), 0 < f.trim().length)) {
          switch (g2) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              f += e2.charAt(l2);
          }
          g2 = 59;
        }
        switch (g2) {
          case 123:
            f = f.trim();
            q2 = f.charCodeAt(0);
            k2 = 1;
            for (t2 = ++l2; l2 < B3; ) {
              switch (g2 = e2.charCodeAt(l2)) {
                case 123:
                  k2++;
                  break;
                case 125:
                  k2--;
                  break;
                case 47:
                  switch (g2 = e2.charCodeAt(l2 + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u2 = l2 + 1; u2 < J2; ++u2) {
                          switch (e2.charCodeAt(u2)) {
                            case 47:
                              if (42 === g2 && 42 === e2.charCodeAt(u2 - 1) && l2 + 2 !== u2) {
                                l2 = u2 + 1;
                                break a;
                              }
                              break;
                            case 10:
                              if (47 === g2) {
                                l2 = u2 + 1;
                                break a;
                              }
                          }
                        }
                        l2 = u2;
                      }
                  }
                  break;
                case 91:
                  g2++;
                case 40:
                  g2++;
                case 34:
                case 39:
                  for (; l2++ < J2 && e2.charCodeAt(l2) !== g2; ) {
                  }
              }
              if (0 === k2)
                break;
              l2++;
            }
            k2 = e2.substring(t2, l2);
            0 === q2 && (q2 = (f = f.replace(ca, "").trim()).charCodeAt(0));
            switch (q2) {
              case 64:
                0 < r2 && (f = f.replace(N2, ""));
                g2 = f.charCodeAt(1);
                switch (g2) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r2 = c2;
                    break;
                  default:
                    r2 = O2;
                }
                k2 = M2(c2, r2, k2, g2, a2 + 1);
                t2 = k2.length;
                0 < A2 && (r2 = X2(O2, f, I2), C2 = H2(3, k2, r2, c2, D2, z2, t2, g2, a2, h), f = r2.join(""), void 0 !== C2 && 0 === (t2 = (k2 = C2.trim()).length) && (g2 = 0, k2 = ""));
                if (0 < t2)
                  switch (g2) {
                    case 115:
                      f = f.replace(da, ea);
                    case 100:
                    case 109:
                    case 45:
                      k2 = f + "{" + k2 + "}";
                      break;
                    case 107:
                      f = f.replace(fa, "$1 $2");
                      k2 = f + "{" + k2 + "}";
                      k2 = 1 === w2 || 2 === w2 && L2("@" + k2, 3) ? "@-webkit-" + k2 + "@" + k2 : "@" + k2;
                      break;
                    default:
                      k2 = f + k2, 112 === h && (k2 = (p += k2, ""));
                  }
                else
                  k2 = "";
                break;
              default:
                k2 = M2(c2, X2(c2, f, I2), k2, h, a2 + 1);
            }
            F3 += k2;
            k2 = I2 = r2 = u2 = q2 = 0;
            f = "";
            g2 = e2.charCodeAt(++l2);
            break;
          case 125:
          case 59:
            f = (0 < r2 ? f.replace(N2, "") : f).trim();
            if (1 < (t2 = f.length))
              switch (0 === u2 && (q2 = f.charCodeAt(0), 45 === q2 || 96 < q2 && 123 > q2) && (t2 = (f = f.replace(" ", ":")).length), 0 < A2 && void 0 !== (C2 = H2(1, f, c2, d2, D2, z2, p.length, h, a2, h)) && 0 === (t2 = (f = C2.trim()).length) && (f = "\0\0"), q2 = f.charCodeAt(0), g2 = f.charCodeAt(1), q2) {
                case 0:
                  break;
                case 64:
                  if (105 === g2 || 99 === g2) {
                    G3 += f + e2.charAt(l2);
                    break;
                  }
                default:
                  58 !== f.charCodeAt(t2 - 1) && (p += P2(f, q2, g2, f.charCodeAt(2)));
              }
            I2 = r2 = u2 = q2 = 0;
            f = "";
            g2 = e2.charCodeAt(++l2);
        }
      }
      switch (g2) {
        case 13:
        case 10:
          47 === b2 ? b2 = 0 : 0 === 1 + q2 && 107 !== h && 0 < f.length && (r2 = 1, f += "\0");
          0 < A2 * Y2 && H2(0, f, c2, d2, D2, z2, p.length, h, a2, h);
          z2 = 1;
          D2++;
          break;
        case 59:
        case 125:
          if (0 === b2 + n2 + v2 + m2) {
            z2++;
            break;
          }
        default:
          z2++;
          y2 = e2.charAt(l2);
          switch (g2) {
            case 9:
            case 32:
              if (0 === n2 + m2 + b2)
                switch (x2) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    y2 = "";
                    break;
                  default:
                    32 !== g2 && (y2 = " ");
                }
              break;
            case 0:
              y2 = "\\0";
              break;
            case 12:
              y2 = "\\f";
              break;
            case 11:
              y2 = "\\v";
              break;
            case 38:
              0 === n2 + b2 + m2 && (r2 = I2 = 1, y2 = "\f" + y2);
              break;
            case 108:
              if (0 === n2 + b2 + m2 + E2 && 0 < u2)
                switch (l2 - u2) {
                  case 2:
                    112 === x2 && 58 === e2.charCodeAt(l2 - 3) && (E2 = x2);
                  case 8:
                    111 === K2 && (E2 = K2);
                }
              break;
            case 58:
              0 === n2 + b2 + m2 && (u2 = l2);
              break;
            case 44:
              0 === b2 + v2 + n2 + m2 && (r2 = 1, y2 += "\r");
              break;
            case 34:
            case 39:
              0 === b2 && (n2 = n2 === g2 ? 0 : 0 === n2 ? g2 : n2);
              break;
            case 91:
              0 === n2 + b2 + v2 && m2++;
              break;
            case 93:
              0 === n2 + b2 + v2 && m2--;
              break;
            case 41:
              0 === n2 + b2 + m2 && v2--;
              break;
            case 40:
              if (0 === n2 + b2 + m2) {
                if (0 === q2)
                  switch (2 * x2 + 3 * K2) {
                    case 533:
                      break;
                    default:
                      q2 = 1;
                  }
                v2++;
              }
              break;
            case 64:
              0 === b2 + v2 + n2 + m2 + u2 + k2 && (k2 = 1);
              break;
            case 42:
            case 47:
              if (!(0 < n2 + m2 + v2))
                switch (b2) {
                  case 0:
                    switch (2 * g2 + 3 * e2.charCodeAt(l2 + 1)) {
                      case 235:
                        b2 = 47;
                        break;
                      case 220:
                        t2 = l2, b2 = 42;
                    }
                    break;
                  case 42:
                    47 === g2 && 42 === x2 && t2 + 2 !== l2 && (33 === e2.charCodeAt(t2 + 2) && (p += e2.substring(t2, l2 + 1)), y2 = "", b2 = 0);
                }
          }
          0 === b2 && (f += y2);
      }
      K2 = x2;
      x2 = g2;
      l2++;
    }
    t2 = p.length;
    if (0 < t2) {
      r2 = c2;
      if (0 < A2 && (C2 = H2(2, p, r2, d2, D2, z2, t2, h, a2, h), void 0 !== C2 && 0 === (p = C2).length))
        return G3 + p + F3;
      p = r2.join(",") + "{" + p + "}";
      if (0 !== w2 * E2) {
        2 !== w2 || L2(p, 2) || (E2 = 0);
        switch (E2) {
          case 111:
            p = p.replace(ha, ":-moz-$1") + p;
            break;
          case 112:
            p = p.replace(Q2, "::-webkit-input-$1") + p.replace(Q2, "::-moz-$1") + p.replace(Q2, ":-ms-input-$1") + p;
        }
        E2 = 0;
      }
    }
    return G3 + p + F3;
  }
  function X2(d2, c2, e2) {
    var h = c2.trim().split(ia);
    c2 = h;
    var a2 = h.length, m2 = d2.length;
    switch (m2) {
      case 0:
      case 1:
        var b2 = 0;
        for (d2 = 0 === m2 ? "" : d2[0] + " "; b2 < a2; ++b2) {
          c2[b2] = Z2(d2, c2[b2], e2).trim();
        }
        break;
      default:
        var v2 = b2 = 0;
        for (c2 = []; b2 < a2; ++b2) {
          for (var n2 = 0; n2 < m2; ++n2) {
            c2[v2++] = Z2(d2[n2] + " ", h[b2], e2).trim();
          }
        }
    }
    return c2;
  }
  function Z2(d2, c2, e2) {
    var h = c2.charCodeAt(0);
    33 > h && (h = (c2 = c2.trim()).charCodeAt(0));
    switch (h) {
      case 38:
        return c2.replace(F2, "$1" + d2.trim());
      case 58:
        return d2.trim() + c2.replace(F2, "$1" + d2.trim());
      default:
        if (0 < 1 * e2 && 0 < c2.indexOf("\f"))
          return c2.replace(F2, (58 === d2.charCodeAt(0) ? "" : "$1") + d2.trim());
    }
    return d2 + c2;
  }
  function P2(d2, c2, e2, h) {
    var a2 = d2 + ";", m2 = 2 * c2 + 3 * e2 + 4 * h;
    if (944 === m2) {
      d2 = a2.indexOf(":", 9) + 1;
      var b2 = a2.substring(d2, a2.length - 1).trim();
      b2 = a2.substring(0, d2).trim() + b2 + ";";
      return 1 === w2 || 2 === w2 && L2(b2, 1) ? "-webkit-" + b2 + b2 : b2;
    }
    if (0 === w2 || 2 === w2 && !L2(a2, 1))
      return a2;
    switch (m2) {
      case 1015:
        return 97 === a2.charCodeAt(10) ? "-webkit-" + a2 + a2 : a2;
      case 951:
        return 116 === a2.charCodeAt(3) ? "-webkit-" + a2 + a2 : a2;
      case 963:
        return 110 === a2.charCodeAt(5) ? "-webkit-" + a2 + a2 : a2;
      case 1009:
        if (100 !== a2.charCodeAt(4))
          break;
      case 969:
      case 942:
        return "-webkit-" + a2 + a2;
      case 978:
        return "-webkit-" + a2 + "-moz-" + a2 + a2;
      case 1019:
      case 983:
        return "-webkit-" + a2 + "-moz-" + a2 + "-ms-" + a2 + a2;
      case 883:
        if (45 === a2.charCodeAt(8))
          return "-webkit-" + a2 + a2;
        if (0 < a2.indexOf("image-set(", 11))
          return a2.replace(ja, "$1-webkit-$2") + a2;
        break;
      case 932:
        if (45 === a2.charCodeAt(4))
          switch (a2.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + a2.replace("-grow", "") + "-webkit-" + a2 + "-ms-" + a2.replace("grow", "positive") + a2;
            case 115:
              return "-webkit-" + a2 + "-ms-" + a2.replace("shrink", "negative") + a2;
            case 98:
              return "-webkit-" + a2 + "-ms-" + a2.replace("basis", "preferred-size") + a2;
          }
        return "-webkit-" + a2 + "-ms-" + a2 + a2;
      case 964:
        return "-webkit-" + a2 + "-ms-flex-" + a2 + a2;
      case 1023:
        if (99 !== a2.charCodeAt(8))
          break;
        b2 = a2.substring(a2.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify");
        return "-webkit-box-pack" + b2 + "-webkit-" + a2 + "-ms-flex-pack" + b2 + a2;
      case 1005:
        return ka.test(a2) ? a2.replace(aa, ":-webkit-") + a2.replace(aa, ":-moz-") + a2 : a2;
      case 1e3:
        b2 = a2.substring(13).trim();
        c2 = b2.indexOf("-") + 1;
        switch (b2.charCodeAt(0) + b2.charCodeAt(c2)) {
          case 226:
            b2 = a2.replace(G2, "tb");
            break;
          case 232:
            b2 = a2.replace(G2, "tb-rl");
            break;
          case 220:
            b2 = a2.replace(G2, "lr");
            break;
          default:
            return a2;
        }
        return "-webkit-" + a2 + "-ms-" + b2 + a2;
      case 1017:
        if (-1 === a2.indexOf("sticky", 9))
          break;
      case 975:
        c2 = (a2 = d2).length - 10;
        b2 = (33 === a2.charCodeAt(c2) ? a2.substring(0, c2) : a2).substring(d2.indexOf(":", 7) + 1).trim();
        switch (m2 = b2.charCodeAt(0) + (b2.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b2.charCodeAt(8))
              break;
          case 115:
            a2 = a2.replace(b2, "-webkit-" + b2) + ";" + a2;
            break;
          case 207:
          case 102:
            a2 = a2.replace(b2, "-webkit-" + (102 < m2 ? "inline-" : "") + "box") + ";" + a2.replace(b2, "-webkit-" + b2) + ";" + a2.replace(b2, "-ms-" + b2 + "box") + ";" + a2;
        }
        return a2 + ";";
      case 938:
        if (45 === a2.charCodeAt(5))
          switch (a2.charCodeAt(6)) {
            case 105:
              return b2 = a2.replace("-items", ""), "-webkit-" + a2 + "-webkit-box-" + b2 + "-ms-flex-" + b2 + a2;
            case 115:
              return "-webkit-" + a2 + "-ms-flex-item-" + a2.replace(ba, "") + a2;
            default:
              return "-webkit-" + a2 + "-ms-flex-line-pack" + a2.replace("align-content", "").replace(ba, "") + a2;
          }
        break;
      case 973:
      case 989:
        if (45 !== a2.charCodeAt(3) || 122 === a2.charCodeAt(4))
          break;
      case 931:
      case 953:
        if (true === la.test(d2))
          return 115 === (b2 = d2.substring(d2.indexOf(":") + 1)).charCodeAt(0) ? P2(d2.replace("stretch", "fill-available"), c2, e2, h).replace(":fill-available", ":stretch") : a2.replace(b2, "-webkit-" + b2) + a2.replace(b2, "-moz-" + b2.replace("fill-", "")) + a2;
        break;
      case 962:
        if (a2 = "-webkit-" + a2 + (102 === a2.charCodeAt(5) ? "-ms-" + a2 : "") + a2, 211 === e2 + h && 105 === a2.charCodeAt(13) && 0 < a2.indexOf("transform", 10))
          return a2.substring(0, a2.indexOf(";", 27) + 1).replace(ma, "$1-webkit-$2") + a2;
    }
    return a2;
  }
  function L2(d2, c2) {
    var e2 = d2.indexOf(1 === c2 ? ":" : "{"), h = d2.substring(0, 3 !== c2 ? e2 : 10);
    e2 = d2.substring(e2 + 1, d2.length - 1);
    return R2(2 !== c2 ? h : h.replace(na, "$1"), e2, c2);
  }
  function ea(d2, c2) {
    var e2 = P2(c2, c2.charCodeAt(0), c2.charCodeAt(1), c2.charCodeAt(2));
    return e2 !== c2 + ";" ? e2.replace(oa, " or ($1)").substring(4) : "(" + c2 + ")";
  }
  function H2(d2, c2, e2, h, a2, m2, b2, v2, n2, q2) {
    for (var g2 = 0, x2 = c2, w3; g2 < A2; ++g2) {
      switch (w3 = S2[g2].call(B2, d2, x2, e2, h, a2, m2, b2, v2, n2, q2)) {
        case void 0:
        case false:
        case true:
        case null:
          break;
        default:
          x2 = w3;
      }
    }
    if (x2 !== c2)
      return x2;
  }
  function T2(d2) {
    switch (d2) {
      case void 0:
      case null:
        A2 = S2.length = 0;
        break;
      default:
        if ("function" === typeof d2)
          S2[A2++] = d2;
        else if ("object" === typeof d2)
          for (var c2 = 0, e2 = d2.length; c2 < e2; ++c2) {
            T2(d2[c2]);
          }
        else
          Y2 = !!d2 | 0;
    }
    return T2;
  }
  function U2(d2) {
    d2 = d2.prefix;
    void 0 !== d2 && (R2 = null, d2 ? "function" !== typeof d2 ? w2 = 1 : (w2 = 2, R2 = d2) : w2 = 0);
    return U2;
  }
  function B2(d2, c2) {
    var e2 = d2;
    33 > e2.charCodeAt(0) && (e2 = e2.trim());
    V2 = e2;
    e2 = [V2];
    if (0 < A2) {
      var h = H2(-1, c2, e2, e2, D2, z2, 0, 0, 0, 0);
      void 0 !== h && "string" === typeof h && (c2 = h);
    }
    var a2 = M2(O2, e2, c2, 0, 0);
    0 < A2 && (h = H2(-2, a2, e2, e2, D2, z2, a2.length, 0, 0, 0), void 0 !== h && (a2 = h));
    V2 = "";
    E2 = 0;
    z2 = D2 = 1;
    return a2;
  }
  var ca = /^\0+/g, N2 = /[\0\r\f]/g, aa = /: */g, ka = /zoo|gra/, ma = /([,: ])(transform)/g, ia = /,\r+?/g, F2 = /([\t\r\n ])*\f?&/g, fa = /@(k\w+)\s*(\S*)\s*/, Q2 = /::(place)/g, ha = /:(read-only)/g, G2 = /[svh]\w+-[tblr]{2}/, da = /\(\s*(.*)\s*\)/g, oa = /([\s\S]*?);/g, ba = /-self|flex-/g, na = /[^]*?(:[rp][el]a[\w-]+)[^]*/, la = /stretch|:\s*\w+\-(?:conte|avail)/, ja = /([^-])(image-set\()/, z2 = 1, D2 = 1, E2 = 0, w2 = 1, O2 = [], S2 = [], A2 = 0, R2 = null, Y2 = 0, V2 = "";
  B2.use = T2;
  B2.set = U2;
  void 0 !== W2 && U2(W2);
  return B2;
}
var stylis_browser_esm_default;
var init_stylis_browser_esm = __esm({
  "node_modules/@emotion/stylis/dist/stylis.browser.esm.js"() {
    stylis_browser_esm_default = stylis_min;
  }
});

// node_modules/@jaredreisinger/react-crossword/node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys, unitless_browser_esm_default;
var init_unitless_browser_esm = __esm({
  "node_modules/@jaredreisinger/react-crossword/node_modules/@emotion/unitless/dist/unitless.browser.esm.js"() {
    unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    unitless_browser_esm_default = unitlessKeys;
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development2();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is2();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i2 = 0; i2 < keys.length; ++i2) {
          var key = keys[i2];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e2) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics;
  }
});

// node_modules/@jaredreisinger/react-crossword/node_modules/styled-components/dist/styled-components.browser.esm.js
var styled_components_browser_esm_exports = {};
__export(styled_components_browser_esm_exports, {
  ServerStyleSheet: () => Ue,
  StyleSheetConsumer: () => ue,
  StyleSheetContext: () => ce,
  StyleSheetManager: () => me,
  ThemeConsumer: () => Ge,
  ThemeContext: () => Me,
  ThemeProvider: () => Le,
  __PRIVATE__: () => Ze,
  createGlobalStyle: () => $e,
  css: () => Ae,
  default: () => styled_components_browser_esm_default,
  isStyledComponent: () => _,
  keyframes: () => We,
  useTheme: () => Xe,
  version: () => A,
  withTheme: () => Je
});
function y() {
  return (y = Object.assign || function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }).apply(this, arguments);
}
function E(e2) {
  return "function" == typeof e2;
}
function b(e2) {
  return "string" == typeof e2 && e2 || e2.displayName || e2.name || "Component";
}
function _(e2) {
  return e2 && "string" == typeof e2.styledComponentId;
}
function R() {
  for (var e2 = arguments.length <= 0 ? void 0 : arguments[0], t2 = [], n2 = 1, r2 = arguments.length; n2 < r2; n2 += 1)
    t2.push(n2 < 0 || arguments.length <= n2 ? void 0 : arguments[n2]);
  return t2.forEach(function(t3) {
    e2 = e2.replace(/%[a-z]/, t3);
  }), e2;
}
function D(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  throw false ? new Error("An error occurred. See https://git.io/JUIaE#" + e2 + " for more information." + (n2.length > 0 ? " Args: " + n2.join(", ") : "")) : new Error(R.apply(void 0, [O[e2]].concat(n2)).trim());
}
function Q(e2) {
  var t2, n2 = "";
  for (t2 = Math.abs(e2); t2 > 52; t2 = t2 / 52 | 0)
    n2 = K(t2 % 52) + n2;
  return (K(t2 % 52) + n2).replace(Z, "$1-$2");
}
function ne(e2) {
  for (var t2 = 0; t2 < e2.length; t2 += 1) {
    var n2 = e2[t2];
    if (E(n2) && !_(n2))
      return false;
  }
  return true;
}
function ae(e2) {
  var t2, n2, r2, o2, s2 = void 0 === e2 ? w : e2, i2 = s2.options, a2 = void 0 === i2 ? w : i2, c2 = s2.plugins, u2 = void 0 === c2 ? S : c2, l2 = new stylis_browser_esm_default(a2), d2 = [], p = /* @__PURE__ */ function(e3) {
    function t3(t4) {
      if (t4)
        try {
          e3(t4 + "}");
        } catch (e4) {
        }
    }
    return function(n3, r3, o3, s3, i3, a3, c3, u3, l3, d3) {
      switch (n3) {
        case 1:
          if (0 === l3 && 64 === r3.charCodeAt(0))
            return e3(r3 + ";"), "";
          break;
        case 2:
          if (0 === u3)
            return r3 + "/*|*/";
          break;
        case 3:
          switch (u3) {
            case 102:
            case 112:
              return e3(o3[0] + r3), "";
            default:
              return r3 + (0 === d3 ? "/*|*/" : "");
          }
        case -2:
          r3.split("/*|*/}").forEach(t3);
      }
    };
  }(function(e3) {
    d2.push(e3);
  }), f = function(e3, r3, s3) {
    return 0 === r3 && -1 !== ie.indexOf(s3[n2.length]) || s3.match(o2) ? e3 : "." + t2;
  };
  function m2(e3, s3, i3, a3) {
    void 0 === a3 && (a3 = "&");
    var c3 = e3.replace(se, ""), u3 = s3 && i3 ? i3 + " " + s3 + " { " + c3 + " }" : c3;
    return t2 = a3, n2 = s3, r2 = new RegExp("\\" + n2 + "\\b", "g"), o2 = new RegExp("(\\" + n2 + "\\b){2,}"), l2(i3 || !s3 ? "" : s3, u3);
  }
  return l2.use([].concat(u2, [function(e3, t3, o3) {
    2 === e3 && o3.length && o3[0].lastIndexOf(n2) > 0 && (o3[0] = o3[0].replace(r2, f));
  }, p, function(e3) {
    if (-2 === e3) {
      var t3 = d2;
      return d2 = [], t3;
    }
  }])), m2.hash = u2.length ? u2.reduce(function(e3, t3) {
    return t3.name || D(15), ee(e3, t3.name);
  }, 5381).toString() : "", m2;
}
function pe() {
  return (0, import_react.useContext)(ce) || de;
}
function fe() {
  return (0, import_react.useContext)(le) || he;
}
function me(e2) {
  var t2 = (0, import_react.useState)(e2.stylisPlugins), n2 = t2[0], s2 = t2[1], c2 = pe(), u2 = (0, import_react.useMemo)(function() {
    var t3 = c2;
    return e2.sheet ? t3 = e2.sheet : e2.target && (t3 = t3.reconstructWithOptions({ target: e2.target }, false)), e2.disableCSSOMInjection && (t3 = t3.reconstructWithOptions({ useCSSOMInjection: false })), t3;
  }, [e2.disableCSSOMInjection, e2.sheet, e2.target]), l2 = (0, import_react.useMemo)(function() {
    return ae({ options: { prefix: !e2.disableVendorPrefixes }, plugins: n2 });
  }, [e2.disableVendorPrefixes, n2]);
  return (0, import_react.useEffect)(function() {
    (0, import_shallowequal.default)(n2, e2.stylisPlugins) || s2(e2.stylisPlugins);
  }, [e2.stylisPlugins]), import_react.default.createElement(ce.Provider, { value: u2 }, import_react.default.createElement(le.Provider, { value: l2 }, true ? import_react.default.Children.only(e2.children) : e2.children));
}
function Ee(e2) {
  return ve.test(e2) ? e2.replace(ge, we).replace(Se, "-ms-") : e2;
}
function _e(e2, n2, r2, o2) {
  if (Array.isArray(e2)) {
    for (var s2, i2 = [], a2 = 0, c2 = e2.length; a2 < c2; a2 += 1)
      "" !== (s2 = _e(e2[a2], n2, r2, o2)) && (Array.isArray(s2) ? i2.push.apply(i2, s2) : i2.push(s2));
    return i2;
  }
  if (be(e2))
    return "";
  if (_(e2))
    return "." + e2.styledComponentId;
  if (E(e2)) {
    if ("function" != typeof (l2 = e2) || l2.prototype && l2.prototype.isReactComponent || !n2)
      return e2;
    var u2 = e2(n2);
    return (0, import_react_is.isElement)(u2) && console.warn(b(e2) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), _e(u2, n2, r2, o2);
  }
  var l2;
  return e2 instanceof ye ? r2 ? (e2.inject(r2, o2), e2.getName(o2)) : e2 : g(e2) ? function e3(t2, n3) {
    var r3, o3, s3 = [];
    for (var i3 in t2)
      t2.hasOwnProperty(i3) && !be(t2[i3]) && (Array.isArray(t2[i3]) && t2[i3].isCss || E(t2[i3]) ? s3.push(Ee(i3) + ":", t2[i3], ";") : g(t2[i3]) ? s3.push.apply(s3, e3(t2[i3], i3)) : s3.push(Ee(i3) + ": " + (r3 = i3, null == (o3 = t2[i3]) || "boolean" == typeof o3 || "" === o3 ? "" : "number" != typeof o3 || 0 === o3 || r3 in unitless_browser_esm_default || r3.startsWith("--") ? String(o3).trim() : o3 + "px") + ";"));
    return n3 ? [n3 + " {"].concat(s3, ["}"]) : s3;
  }(e2) : e2.toString();
}
function Ae(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  return E(e2) || g(e2) ? Ne(_e(v(S, [e2].concat(n2)))) : 0 === n2.length && 1 === e2.length && "string" == typeof e2[0] ? e2 : Ne(_e(v(e2, n2)));
}
function je(e2) {
  return e2.replace(Re, "-").replace(De, "");
}
function xe(e2) {
  return "string" == typeof e2 && e2.charAt(0) === e2.charAt(0).toLowerCase();
}
function Be(e2, t2, n2) {
  var r2 = e2[n2];
  ke(t2) && ke(r2) ? ze(r2, t2) : e2[n2] = t2;
}
function ze(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  for (var o2 = 0, s2 = n2; o2 < s2.length; o2++) {
    var i2 = s2[o2];
    if (ke(i2))
      for (var a2 in i2)
        Ve(a2) && Be(e2, i2[a2], a2);
  }
  return e2;
}
function Le(e2) {
  var t2 = (0, import_react.useContext)(Me), n2 = (0, import_react.useMemo)(function() {
    return function(e3, t3) {
      if (!e3)
        return D(14);
      if (E(e3)) {
        var n3 = e3(t3);
        return null !== n3 && !Array.isArray(n3) && "object" == typeof n3 ? n3 : D(7);
      }
      return Array.isArray(e3) || "object" != typeof e3 ? D(8) : t3 ? y({}, t3, {}, e3) : e3;
    }(e2.theme, t2);
  }, [e2.theme, t2]);
  return e2.children ? import_react.default.createElement(Me.Provider, { value: n2 }, e2.children) : null;
}
function Ye(e2, t2, n2) {
  var o2 = _(e2), i2 = !xe(e2), a2 = t2.attrs, c2 = void 0 === a2 ? S : a2, l2 = t2.componentId, d2 = void 0 === l2 ? function(e3, t3) {
    var n3 = "string" != typeof e3 ? "sc" : je(e3);
    Fe[n3] = (Fe[n3] || 0) + 1;
    var r2 = n3 + "-" + Te("5.3.11" + n3 + Fe[n3]);
    return t3 ? t3 + "-" + r2 : r2;
  }(t2.displayName, t2.parentComponentId) : l2, h = t2.displayName, p = void 0 === h ? function(e3) {
    return xe(e3) ? "styled." + e3 : "Styled(" + b(e3) + ")";
  }(e2) : h, v2 = t2.displayName && t2.componentId ? je(t2.displayName) + "-" + t2.componentId : t2.componentId || d2, g2 = o2 && e2.attrs ? Array.prototype.concat(e2.attrs, c2).filter(Boolean) : c2, N2 = t2.shouldForwardProp;
  o2 && e2.shouldForwardProp && (N2 = t2.shouldForwardProp ? function(n3, r2, o3) {
    return e2.shouldForwardProp(n3, r2, o3) && t2.shouldForwardProp(n3, r2, o3);
  } : e2.shouldForwardProp);
  var A2, C2 = new oe(n2, v2, o2 ? e2.componentStyle : void 0), I2 = C2.isStatic && 0 === c2.length, P2 = function(e3, t3) {
    return function(e4, t4, n3, r2) {
      var o3 = e4.attrs, i3 = e4.componentStyle, a3 = e4.defaultProps, c3 = e4.foldedComponentIds, l3 = e4.shouldForwardProp, d3 = e4.styledComponentId, h2 = e4.target, p2 = function(e5, t5, n4) {
        void 0 === e5 && (e5 = w);
        var r3 = y({}, t5, { theme: e5 }), o4 = {};
        return n4.forEach(function(e6) {
          var t6, n5, s2, i4 = e6;
          for (t6 in E(i4) && (i4 = i4(r3)), i4)
            r3[t6] = o4[t6] = "className" === t6 ? (n5 = o4[t6], s2 = i4[t6], n5 && s2 ? n5 + " " + s2 : n5 || s2) : i4[t6];
        }), [r3, o4];
      }(Oe(t4, (0, import_react.useContext)(Me), a3) || w, t4, o3), m2 = p2[0], v3 = p2[1], g3 = function(e5, t5, n4, r3) {
        var o4 = pe(), s2 = fe(), i4 = t5 ? e5.generateAndInjectStyles(w, o4, s2) : e5.generateAndInjectStyles(n4, o4, s2);
        return !t5 && r3 && r3(i4), i4;
      }(i3, r2, m2, true ? e4.warnTooManyClasses : void 0), S2 = n3, b2 = v3.$as || t4.$as || v3.as || t4.as || h2, _2 = xe(b2), N3 = v3 !== t4 ? y({}, t4, {}, v3) : t4, A3 = {};
      for (var C3 in N3)
        "$" !== C3[0] && "as" !== C3 && ("forwardedAs" === C3 ? A3.as = N3[C3] : (l3 ? l3(C3, isPropValid, b2) : !_2 || isPropValid(C3)) && (A3[C3] = N3[C3]));
      return t4.style && v3.style !== t4.style && (A3.style = y({}, t4.style, {}, v3.style)), A3.className = Array.prototype.concat(c3, d3, g3 !== d3 ? g3 : null, t4.className, v3.className).filter(Boolean).join(" "), A3.ref = S2, (0, import_react.createElement)(b2, A3);
    }(A2, e3, t3, I2);
  };
  return P2.displayName = p, (A2 = import_react.default.forwardRef(P2)).attrs = g2, A2.componentStyle = C2, A2.displayName = p, A2.shouldForwardProp = N2, A2.foldedComponentIds = o2 ? Array.prototype.concat(e2.foldedComponentIds, e2.styledComponentId) : S, A2.styledComponentId = v2, A2.target = o2 ? e2.target : e2, A2.withComponent = function(e3) {
    var r2 = t2.componentId, o3 = function(e4, t3) {
      if (null == e4)
        return {};
      var n3, r3, o4 = {}, s3 = Object.keys(e4);
      for (r3 = 0; r3 < s3.length; r3++)
        n3 = s3[r3], t3.indexOf(n3) >= 0 || (o4[n3] = e4[n3]);
      return o4;
    }(t2, ["componentId"]), s2 = r2 && r2 + "-" + (xe(e3) ? e3 : je(b(e3)));
    return Ye(e3, y({}, o3, { attrs: g2, componentId: s2 }), n2);
  }, Object.defineProperty(A2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(t3) {
    this._foldedDefaultProps = o2 ? ze({}, e2.defaultProps, t3) : t3;
  } }), Pe(p, v2), A2.warnTooManyClasses = /* @__PURE__ */ function(e3, t3) {
    var n3 = {}, r2 = false;
    return function(o3) {
      if (!r2 && (n3[o3] = true, Object.keys(n3).length >= 200)) {
        var s2 = t3 ? ' with the id of "' + t3 + '"' : "";
        console.warn("Over 200 classes were generated for component " + e3 + s2 + ".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), r2 = true, n3 = {};
      }
    };
  }(p, v2), Object.defineProperty(A2, "toString", { value: function() {
    return "." + A2.styledComponentId;
  } }), i2 && (0, import_hoist_non_react_statics.default)(A2, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), A2;
}
function $e(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), o2 = 1; o2 < t2; o2++)
    n2[o2 - 1] = arguments[o2];
  var i2 = Ae.apply(void 0, [e2].concat(n2)), a2 = "sc-global-" + Te(JSON.stringify(i2)), u2 = new He(i2, a2);
  function d2(e3) {
    var t3 = pe(), n3 = fe(), o3 = (0, import_react.useContext)(Me), d3 = (0, import_react.useRef)(t3.allocateGSInstance(a2)).current;
    return import_react.default.Children.count(e3.children) && console.warn("The global style component " + a2 + " was given child JSX. createGlobalStyle does not render children."), i2.some(function(e4) {
      return "string" == typeof e4 && -1 !== e4.indexOf("@import");
    }) && console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."), t3.server && h(d3, e3, t3, o3, n3), (0, import_react.useLayoutEffect)(function() {
      if (!t3.server)
        return h(d3, e3, t3, o3, n3), function() {
          return u2.removeStyles(d3, t3);
        };
    }, [d3, e3, t3, o3, n3]), null;
  }
  function h(e3, t3, n3, r2, o3) {
    if (u2.isStatic)
      u2.renderStyles(e3, P, n3, o3);
    else {
      var s2 = y({}, t3, { theme: Oe(t3, r2, d2.defaultProps) });
      u2.renderStyles(e3, s2, n3, o3);
    }
  }
  return Pe(a2), import_react.default.memo(d2);
}
function We(e2) {
  "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
    n2[r2 - 1] = arguments[r2];
  var o2 = Ae.apply(void 0, [e2].concat(n2)).join(""), s2 = Te(o2);
  return new ye(s2, o2);
}
var import_react_is, import_react, import_shallowequal, import_hoist_non_react_statics, v, g, S, w, N, A, C, I, P, O, j, T, x, k, V, B, z, M, G, L, F, Y, q, H, $, W, U, J, X, Z, K, ee, te, re, oe, se, ie, ce, ue, le, de, he, ye, ve, ge, Se, we, be, Ne, Ce, Ie, Pe, Oe, Re, De, Te, ke, Ve, Me, Ge, Fe, qe, He, Ue, Je, Xe, Ze, styled_components_browser_esm_default;
var init_styled_components_browser_esm = __esm({
  "node_modules/@jaredreisinger/react-crossword/node_modules/styled-components/dist/styled-components.browser.esm.js"() {
    import_react_is = __toESM(require_react_is());
    import_react = __toESM(require_react());
    import_shallowequal = __toESM(require_shallowequal());
    init_stylis_browser_esm();
    init_unitless_browser_esm();
    init_emotion_is_prop_valid_esm();
    import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
    v = function(e2, t2) {
      for (var n2 = [e2[0]], r2 = 0, o2 = t2.length; r2 < o2; r2 += 1)
        n2.push(t2[r2], e2[r2 + 1]);
      return n2;
    };
    g = function(t2) {
      return null !== t2 && "object" == typeof t2 && "[object Object]" === (t2.toString ? t2.toString() : Object.prototype.toString.call(t2)) && !(0, import_react_is.typeOf)(t2);
    };
    S = Object.freeze([]);
    w = Object.freeze({});
    N = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
    A = "5.3.11";
    C = "undefined" != typeof window && "HTMLElement" in window;
    I = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && (void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true));
    P = {};
    O = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n" } : {};
    j = function() {
      function e2(e3) {
        this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
      }
      var t2 = e2.prototype;
      return t2.indexOfGroup = function(e3) {
        for (var t3 = 0, n2 = 0; n2 < e3; n2++)
          t3 += this.groupSizes[n2];
        return t3;
      }, t2.insertRules = function(e3, t3) {
        if (e3 >= this.groupSizes.length) {
          for (var n2 = this.groupSizes, r2 = n2.length, o2 = r2; e3 >= o2; )
            (o2 <<= 1) < 0 && D(16, "" + e3);
          this.groupSizes = new Uint32Array(o2), this.groupSizes.set(n2), this.length = o2;
          for (var s2 = r2; s2 < o2; s2++)
            this.groupSizes[s2] = 0;
        }
        for (var i2 = this.indexOfGroup(e3 + 1), a2 = 0, c2 = t3.length; a2 < c2; a2++)
          this.tag.insertRule(i2, t3[a2]) && (this.groupSizes[e3]++, i2++);
      }, t2.clearGroup = function(e3) {
        if (e3 < this.length) {
          var t3 = this.groupSizes[e3], n2 = this.indexOfGroup(e3), r2 = n2 + t3;
          this.groupSizes[e3] = 0;
          for (var o2 = n2; o2 < r2; o2++)
            this.tag.deleteRule(n2);
        }
      }, t2.getGroup = function(e3) {
        var t3 = "";
        if (e3 >= this.length || 0 === this.groupSizes[e3])
          return t3;
        for (var n2 = this.groupSizes[e3], r2 = this.indexOfGroup(e3), o2 = r2 + n2, s2 = r2; s2 < o2; s2++)
          t3 += this.tag.getRule(s2) + "/*!sc*/\n";
        return t3;
      }, e2;
    }();
    T = /* @__PURE__ */ new Map();
    x = /* @__PURE__ */ new Map();
    k = 1;
    V = function(e2) {
      if (T.has(e2))
        return T.get(e2);
      for (; x.has(k); )
        k++;
      var t2 = k++;
      return ((0 | t2) < 0 || t2 > 1 << 30) && D(16, "" + t2), T.set(e2, t2), x.set(t2, e2), t2;
    };
    B = function(e2) {
      return x.get(e2);
    };
    z = function(e2, t2) {
      t2 >= k && (k = t2 + 1), T.set(e2, t2), x.set(t2, e2);
    };
    M = "style[" + N + '][data-styled-version="5.3.11"]';
    G = new RegExp("^" + N + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)');
    L = function(e2, t2, n2) {
      for (var r2, o2 = n2.split(","), s2 = 0, i2 = o2.length; s2 < i2; s2++)
        (r2 = o2[s2]) && e2.registerName(t2, r2);
    };
    F = function(e2, t2) {
      for (var n2 = (t2.textContent || "").split("/*!sc*/\n"), r2 = [], o2 = 0, s2 = n2.length; o2 < s2; o2++) {
        var i2 = n2[o2].trim();
        if (i2) {
          var a2 = i2.match(G);
          if (a2) {
            var c2 = 0 | parseInt(a2[1], 10), u2 = a2[2];
            0 !== c2 && (z(u2, c2), L(e2, u2, a2[3]), e2.getTag().insertRules(c2, r2)), r2.length = 0;
          } else
            r2.push(i2);
        }
      }
    };
    Y = function() {
      return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
    };
    q = function(e2) {
      var t2 = document.head, n2 = e2 || t2, r2 = document.createElement("style"), o2 = function(e3) {
        for (var t3 = e3.childNodes, n3 = t3.length; n3 >= 0; n3--) {
          var r3 = t3[n3];
          if (r3 && 1 === r3.nodeType && r3.hasAttribute(N))
            return r3;
        }
      }(n2), s2 = void 0 !== o2 ? o2.nextSibling : null;
      r2.setAttribute(N, "active"), r2.setAttribute("data-styled-version", "5.3.11");
      var i2 = Y();
      return i2 && r2.setAttribute("nonce", i2), n2.insertBefore(r2, s2), r2;
    };
    H = function() {
      function e2(e3) {
        var t3 = this.element = q(e3);
        t3.appendChild(document.createTextNode("")), this.sheet = function(e4) {
          if (e4.sheet)
            return e4.sheet;
          for (var t4 = document.styleSheets, n2 = 0, r2 = t4.length; n2 < r2; n2++) {
            var o2 = t4[n2];
            if (o2.ownerNode === e4)
              return o2;
          }
          D(17);
        }(t3), this.length = 0;
      }
      var t2 = e2.prototype;
      return t2.insertRule = function(e3, t3) {
        try {
          return this.sheet.insertRule(t3, e3), this.length++, true;
        } catch (e4) {
          return false;
        }
      }, t2.deleteRule = function(e3) {
        this.sheet.deleteRule(e3), this.length--;
      }, t2.getRule = function(e3) {
        var t3 = this.sheet.cssRules[e3];
        return void 0 !== t3 && "string" == typeof t3.cssText ? t3.cssText : "";
      }, e2;
    }();
    $ = function() {
      function e2(e3) {
        var t3 = this.element = q(e3);
        this.nodes = t3.childNodes, this.length = 0;
      }
      var t2 = e2.prototype;
      return t2.insertRule = function(e3, t3) {
        if (e3 <= this.length && e3 >= 0) {
          var n2 = document.createTextNode(t3), r2 = this.nodes[e3];
          return this.element.insertBefore(n2, r2 || null), this.length++, true;
        }
        return false;
      }, t2.deleteRule = function(e3) {
        this.element.removeChild(this.nodes[e3]), this.length--;
      }, t2.getRule = function(e3) {
        return e3 < this.length ? this.nodes[e3].textContent : "";
      }, e2;
    }();
    W = function() {
      function e2(e3) {
        this.rules = [], this.length = 0;
      }
      var t2 = e2.prototype;
      return t2.insertRule = function(e3, t3) {
        return e3 <= this.length && (this.rules.splice(e3, 0, t3), this.length++, true);
      }, t2.deleteRule = function(e3) {
        this.rules.splice(e3, 1), this.length--;
      }, t2.getRule = function(e3) {
        return e3 < this.length ? this.rules[e3] : "";
      }, e2;
    }();
    U = C;
    J = { isServer: !C, useCSSOMInjection: !I };
    X = function() {
      function e2(e3, t3, n2) {
        void 0 === e3 && (e3 = w), void 0 === t3 && (t3 = {}), this.options = y({}, J, {}, e3), this.gs = t3, this.names = new Map(n2), this.server = !!e3.isServer, !this.server && C && U && (U = false, function(e4) {
          for (var t4 = document.querySelectorAll(M), n3 = 0, r2 = t4.length; n3 < r2; n3++) {
            var o2 = t4[n3];
            o2 && "active" !== o2.getAttribute(N) && (F(e4, o2), o2.parentNode && o2.parentNode.removeChild(o2));
          }
        }(this));
      }
      e2.registerId = function(e3) {
        return V(e3);
      };
      var t2 = e2.prototype;
      return t2.reconstructWithOptions = function(t3, n2) {
        return void 0 === n2 && (n2 = true), new e2(y({}, this.options, {}, t3), this.gs, n2 && this.names || void 0);
      }, t2.allocateGSInstance = function(e3) {
        return this.gs[e3] = (this.gs[e3] || 0) + 1;
      }, t2.getTag = function() {
        return this.tag || (this.tag = (n2 = (t3 = this.options).isServer, r2 = t3.useCSSOMInjection, o2 = t3.target, e3 = n2 ? new W(o2) : r2 ? new H(o2) : new $(o2), new j(e3)));
        var e3, t3, n2, r2, o2;
      }, t2.hasNameForId = function(e3, t3) {
        return this.names.has(e3) && this.names.get(e3).has(t3);
      }, t2.registerName = function(e3, t3) {
        if (V(e3), this.names.has(e3))
          this.names.get(e3).add(t3);
        else {
          var n2 = /* @__PURE__ */ new Set();
          n2.add(t3), this.names.set(e3, n2);
        }
      }, t2.insertRules = function(e3, t3, n2) {
        this.registerName(e3, t3), this.getTag().insertRules(V(e3), n2);
      }, t2.clearNames = function(e3) {
        this.names.has(e3) && this.names.get(e3).clear();
      }, t2.clearRules = function(e3) {
        this.getTag().clearGroup(V(e3)), this.clearNames(e3);
      }, t2.clearTag = function() {
        this.tag = void 0;
      }, t2.toString = function() {
        return function(e3) {
          for (var t3 = e3.getTag(), n2 = t3.length, r2 = "", o2 = 0; o2 < n2; o2++) {
            var s2 = B(o2);
            if (void 0 !== s2) {
              var i2 = e3.names.get(s2), a2 = t3.getGroup(o2);
              if (i2 && a2 && i2.size) {
                var c2 = N + ".g" + o2 + '[id="' + s2 + '"]', u2 = "";
                void 0 !== i2 && i2.forEach(function(e4) {
                  e4.length > 0 && (u2 += e4 + ",");
                }), r2 += "" + a2 + c2 + '{content:"' + u2 + '"}/*!sc*/\n';
              }
            }
          }
          return r2;
        }(this);
      }, e2;
    }();
    Z = /(a)(d)/gi;
    K = function(e2) {
      return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
    };
    ee = function(e2, t2) {
      for (var n2 = t2.length; n2; )
        e2 = 33 * e2 ^ t2.charCodeAt(--n2);
      return e2;
    };
    te = function(e2) {
      return ee(5381, e2);
    };
    re = te("5.3.11");
    oe = function() {
      function e2(e3, t2, n2) {
        this.rules = e3, this.staticRulesId = "", this.isStatic = false, this.componentId = t2, this.baseHash = ee(re, t2), this.baseStyle = n2, X.registerId(t2);
      }
      return e2.prototype.generateAndInjectStyles = function(e3, t2, n2) {
        var r2 = this.componentId, o2 = [];
        if (this.baseStyle && o2.push(this.baseStyle.generateAndInjectStyles(e3, t2, n2)), this.isStatic && !n2.hash)
          if (this.staticRulesId && t2.hasNameForId(r2, this.staticRulesId))
            o2.push(this.staticRulesId);
          else {
            var s2 = _e(this.rules, e3, t2, n2).join(""), i2 = Q(ee(this.baseHash, s2) >>> 0);
            if (!t2.hasNameForId(r2, i2)) {
              var a2 = n2(s2, "." + i2, void 0, r2);
              t2.insertRules(r2, i2, a2);
            }
            o2.push(i2), this.staticRulesId = i2;
          }
        else {
          for (var c2 = this.rules.length, u2 = ee(this.baseHash, n2.hash), l2 = "", d2 = 0; d2 < c2; d2++) {
            var h = this.rules[d2];
            if ("string" == typeof h)
              l2 += h, u2 = ee(u2, h + d2);
            else if (h) {
              var p = _e(h, e3, t2, n2), f = Array.isArray(p) ? p.join("") : p;
              u2 = ee(u2, f + d2), l2 += f;
            }
          }
          if (l2) {
            var m2 = Q(u2 >>> 0);
            if (!t2.hasNameForId(r2, m2)) {
              var y2 = n2(l2, "." + m2, void 0, r2);
              t2.insertRules(r2, m2, y2);
            }
            o2.push(m2);
          }
        }
        return o2.join(" ");
      }, e2;
    }();
    se = /^\s*\/\/.*$/gm;
    ie = [":", "[", ".", "#"];
    ce = import_react.default.createContext();
    ue = ce.Consumer;
    le = import_react.default.createContext();
    de = (le.Consumer, new X());
    he = ae();
    ye = function() {
      function e2(e3, t2) {
        var n2 = this;
        this.inject = function(e4, t3) {
          void 0 === t3 && (t3 = he);
          var r2 = n2.name + t3.hash;
          e4.hasNameForId(n2.id, r2) || e4.insertRules(n2.id, r2, t3(n2.rules, r2, "@keyframes"));
        }, this.toString = function() {
          return D(12, String(n2.name));
        }, this.name = e3, this.id = "sc-keyframes-" + e3, this.rules = t2;
      }
      return e2.prototype.getName = function(e3) {
        return void 0 === e3 && (e3 = he), this.name + e3.hash;
      }, e2;
    }();
    ve = /([A-Z])/;
    ge = /([A-Z])/g;
    Se = /^ms-/;
    we = function(e2) {
      return "-" + e2.toLowerCase();
    };
    be = function(e2) {
      return null == e2 || false === e2 || "" === e2;
    };
    Ne = function(e2) {
      return Array.isArray(e2) && (e2.isCss = true), e2;
    };
    Ce = /invalid hook call/i;
    Ie = /* @__PURE__ */ new Set();
    Pe = function(e2, t2) {
      if (true) {
        var n2 = "The component " + e2 + (t2 ? ' with the id of "' + t2 + '"' : "") + " has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.", r2 = console.error;
        try {
          var o2 = true;
          console.error = function(e3) {
            if (Ce.test(e3))
              o2 = false, Ie.delete(n2);
            else {
              for (var t3 = arguments.length, s2 = new Array(t3 > 1 ? t3 - 1 : 0), i2 = 1; i2 < t3; i2++)
                s2[i2 - 1] = arguments[i2];
              r2.apply(void 0, [e3].concat(s2));
            }
          }, (0, import_react.useRef)(), o2 && !Ie.has(n2) && (console.warn(n2), Ie.add(n2));
        } catch (e3) {
          Ce.test(e3.message) && Ie.delete(n2);
        } finally {
          console.error = r2;
        }
      }
    };
    Oe = function(e2, t2, n2) {
      return void 0 === n2 && (n2 = w), e2.theme !== n2.theme && e2.theme || t2 || n2.theme;
    };
    Re = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
    De = /(^-|-$)/g;
    Te = function(e2) {
      return Q(te(e2) >>> 0);
    };
    ke = function(e2) {
      return "function" == typeof e2 || "object" == typeof e2 && null !== e2 && !Array.isArray(e2);
    };
    Ve = function(e2) {
      return "__proto__" !== e2 && "constructor" !== e2 && "prototype" !== e2;
    };
    Me = import_react.default.createContext();
    Ge = Me.Consumer;
    Fe = {};
    qe = function(e2) {
      return function e3(t2, r2, o2) {
        if (void 0 === o2 && (o2 = w), !(0, import_react_is.isValidElementType)(r2))
          return D(1, String(r2));
        var s2 = function() {
          return t2(r2, o2, Ae.apply(void 0, arguments));
        };
        return s2.withConfig = function(n2) {
          return e3(t2, r2, y({}, o2, {}, n2));
        }, s2.attrs = function(n2) {
          return e3(t2, r2, y({}, o2, { attrs: Array.prototype.concat(o2.attrs, n2).filter(Boolean) }));
        }, s2;
      }(Ye, e2);
    };
    ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e2) {
      qe[e2] = qe(e2);
    });
    He = function() {
      function e2(e3, t3) {
        this.rules = e3, this.componentId = t3, this.isStatic = ne(e3), X.registerId(this.componentId + 1);
      }
      var t2 = e2.prototype;
      return t2.createStyles = function(e3, t3, n2, r2) {
        var o2 = r2(_e(this.rules, t3, n2, r2).join(""), ""), s2 = this.componentId + e3;
        n2.insertRules(s2, s2, o2);
      }, t2.removeStyles = function(e3, t3) {
        t3.clearRules(this.componentId + e3);
      }, t2.renderStyles = function(e3, t3, n2, r2) {
        e3 > 2 && X.registerId(this.componentId + e3), this.removeStyles(e3, n2), this.createStyles(e3, t3, n2, r2);
      }, e2;
    }();
    Ue = function() {
      function e2() {
        var e3 = this;
        this._emitSheetCSS = function() {
          var t3 = e3.instance.toString();
          if (!t3)
            return "";
          var n2 = Y();
          return "<style " + [n2 && 'nonce="' + n2 + '"', N + '="true"', 'data-styled-version="5.3.11"'].filter(Boolean).join(" ") + ">" + t3 + "</style>";
        }, this.getStyleTags = function() {
          return e3.sealed ? D(2) : e3._emitSheetCSS();
        }, this.getStyleElement = function() {
          var t3;
          if (e3.sealed)
            return D(2);
          var n2 = ((t3 = {})[N] = "", t3["data-styled-version"] = "5.3.11", t3.dangerouslySetInnerHTML = { __html: e3.instance.toString() }, t3), o2 = Y();
          return o2 && (n2.nonce = o2), [import_react.default.createElement("style", y({}, n2, { key: "sc-0-0" }))];
        }, this.seal = function() {
          e3.sealed = true;
        }, this.instance = new X({ isServer: true }), this.sealed = false;
      }
      var t2 = e2.prototype;
      return t2.collectStyles = function(e3) {
        return this.sealed ? D(2) : import_react.default.createElement(me, { sheet: this.instance }, e3);
      }, t2.interleaveWithNodeStream = function(e3) {
        return D(3);
      }, e2;
    }();
    Je = function(e2) {
      var t2 = import_react.default.forwardRef(function(t3, n2) {
        var o2 = (0, import_react.useContext)(Me), i2 = e2.defaultProps, a2 = Oe(t3, o2, i2);
        return void 0 === a2 && console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class "' + b(e2) + '"'), import_react.default.createElement(e2, y({}, t3, { theme: a2, ref: n2 }));
      });
      return (0, import_hoist_non_react_statics.default)(t2, e2), t2.displayName = "WithTheme(" + b(e2) + ")", t2;
    };
    Xe = function() {
      return (0, import_react.useContext)(Me);
    };
    Ze = { StyleSheet: X, masterSheet: de };
    "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), "undefined" != typeof window && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, 1 === window["__styled-components-init__"] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window["__styled-components-init__"] += 1);
    styled_components_browser_esm_default = qe;
  }
});

// node_modules/@jaredreisinger/react-crossword/dist/context.js
var require_context = __commonJS({
  "node_modules/@jaredreisinger/react-crossword/dist/context.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CrosswordSizeContext = exports.CrosswordContext = void 0;
    var react_1 = __importDefault(require_react());
    function nop() {
    }
    exports.CrosswordContext = react_1.default.createContext({
      rows: 0,
      cols: 0,
      gridData: [],
      // clues: { across: [], down: [] },
      handleInputKeyDown: nop,
      handleInputChange: nop,
      handleCellClick: nop,
      handleInputClick: nop,
      handleClueSelected: nop,
      registerFocusHandler: nop,
      focused: false,
      selectedPosition: { row: 0, col: 0 },
      selectedDirection: "across",
      selectedNumber: "",
      crosswordCorrect: false
    });
    exports.CrosswordSizeContext = react_1.default.createContext({
      cellSize: 0,
      cellPadding: 0,
      cellInner: 0,
      cellHalf: 0,
      fontSize: 0
    });
  }
});

// node_modules/@jaredreisinger/react-crossword/dist/Cell.js
var require_Cell = __commonJS({
  "node_modules/@jaredreisinger/react-crossword/dist/Cell.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var prop_types_1 = __importDefault(require_prop_types());
    var styled_components_1 = (init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports));
    var context_1 = require_context();
    var cellPropTypes = {
      /** the data specific to this cell */
      cellData: prop_types_1.default.shape({
        row: prop_types_1.default.number.isRequired,
        col: prop_types_1.default.number.isRequired,
        guess: prop_types_1.default.string,
        number: prop_types_1.default.string,
        answer: prop_types_1.default.string
      }).isRequired,
      /** whether this cell has focus */
      focus: prop_types_1.default.bool,
      /** whether this cell is highlighted */
      highlight: prop_types_1.default.bool,
      /** handler called when the cell is clicked */
      onClick: prop_types_1.default.func
    };
    function Cell({ cellData, onClick, focus, highlight }) {
      const { cellSize, cellPadding, cellInner, cellHalf, fontSize } = (0, react_1.useContext)(context_1.CrosswordSizeContext);
      const {
        // gridBackground,
        cellBackground,
        cellBorder,
        textColor,
        numberColor,
        focusBackground,
        highlightBackground
      } = (0, react_1.useContext)(styled_components_1.ThemeContext);
      const handleClick = (0, react_1.useCallback)((event) => {
        event.preventDefault();
        if (onClick) {
          onClick(cellData);
        }
      }, [cellData, onClick]);
      const { row, col, guess, number, answer } = cellData;
      const x2 = col * cellSize;
      const y2 = row * cellSize;
      return (0, jsx_runtime_1.jsxs)("g", Object.assign({ onClick: handleClick, style: { cursor: "default", fontSize: `${fontSize}px` }, className: "clue-cell" }, { children: [(0, jsx_runtime_1.jsx)("rect", { x: x2 + cellPadding, y: y2 + cellPadding, width: cellInner, height: cellInner, fill: focus ? focusBackground : highlight ? highlightBackground : cellBackground, stroke: cellBorder, strokeWidth: cellSize / 50 }), number && (0, jsx_runtime_1.jsx)("text", Object.assign({ x: x2 + cellPadding * 4, y: y2 + cellPadding * 4, textAnchor: "start", dominantBaseline: "hanging", style: { fontSize: "50%", fill: numberColor } }, { children: number })), (0, jsx_runtime_1.jsx)("text", Object.assign({ x: x2 + cellHalf, y: y2 + cellHalf + 1, textAnchor: "middle", dominantBaseline: "middle", style: { fill: textColor }, className: answer === guess ? "guess-text-correct" : "guess-text-incorrect" }, { children: guess }))] }));
    }
    exports.default = Cell;
    Cell.propTypes = cellPropTypes;
    Cell.defaultProps = {
      focus: false,
      highlight: false,
      onClick: null
    };
  }
});

// node_modules/@jaredreisinger/react-crossword/dist/Clue.js
var require_Clue = __commonJS({
  "node_modules/@jaredreisinger/react-crossword/dist/Clue.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var prop_types_1 = __importDefault(require_prop_types());
    var styled_components_1 = __importStar((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var context_1 = require_context();
    var ClueWrapper = styled_components_1.default.div.attrs((props) => ({
      className: `clue${props.complete ? props.correct ? " correct" : " incorrect" : ""}`
    }))`
  cursor: default;
  background-color: ${(props) => props.highlight ? props.highlightBackground : "transparent"};
`;
    function Clue(_a) {
      var { direction, number, children, complete, correct } = _a, props = __rest(_a, ["direction", "number", "children", "complete", "correct"]);
      const { highlightBackground } = (0, react_1.useContext)(styled_components_1.ThemeContext);
      const { focused, selectedDirection, selectedNumber, handleClueSelected } = (0, react_1.useContext)(context_1.CrosswordContext);
      const handleClick = (0, react_1.useCallback)((event) => {
        event.preventDefault();
        handleClueSelected(direction, number);
      }, [direction, number, handleClueSelected]);
      return (0, jsx_runtime_1.jsxs)(ClueWrapper, Object.assign({ highlightBackground, highlight: focused && direction === selectedDirection && number === selectedNumber, complete, correct }, props, { onClick: handleClick, "aria-label": `clue-${number}-${direction}` }, { children: [number, ": ", children] }));
    }
    exports.default = Clue;
    Clue.propTypes = {
      /** direction of the clue: "across" or "down"; passed back in onClick */
      direction: prop_types_1.default.string.isRequired,
      /** number of the clue (the label shown); passed back in onClick */
      number: prop_types_1.default.string.isRequired,
      /** clue text */
      children: prop_types_1.default.node.isRequired,
      /** whether the answer/guess is complete */
      complete: prop_types_1.default.bool,
      /** whether the answer/guess is correct */
      correct: prop_types_1.default.bool
    };
    Clue.defaultProps = {
      // children: undefined,
      complete: void 0,
      correct: void 0
    };
  }
});

// node_modules/@jaredreisinger/react-crossword/dist/DirectionClues.js
var require_DirectionClues = __commonJS({
  "node_modules/@jaredreisinger/react-crossword/dist/DirectionClues.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var prop_types_1 = __importDefault(require_prop_types());
    var context_1 = require_context();
    var Clue_1 = __importDefault(require_Clue());
    var directionCluesPropTypes = {
      /** direction of this list of clues ("across" or "down") */
      direction: prop_types_1.default.string.isRequired,
      /** a label to use instead of the (English) default */
      label: prop_types_1.default.string
    };
    function DirectionClues({ direction, label }) {
      const { clues } = (0, react_1.useContext)(context_1.CrosswordContext);
      return (0, jsx_runtime_1.jsxs)("div", Object.assign({ className: "direction" }, { children: [(0, jsx_runtime_1.jsx)("h3", Object.assign({ className: "header" }, { children: label || direction.toUpperCase() })), clues === null || clues === void 0 ? void 0 : clues[direction].map(({ number, clue, complete, correct }) => (0, jsx_runtime_1.jsx)(Clue_1.default, Object.assign({ direction, number, complete, correct }, { children: clue }), number))] }));
    }
    exports.default = DirectionClues;
    DirectionClues.propTypes = directionCluesPropTypes;
    DirectionClues.defaultProps = {
      label: void 0
    };
  }
});

// node_modules/immer/dist/immer.cjs.development.js
var require_immer_cjs_development = __commonJS({
  "node_modules/immer/dist/immer.cjs.development.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ref;
    var hasSymbol = typeof Symbol !== "undefined" && typeof Symbol("x") === "symbol";
    var hasMap = typeof Map !== "undefined";
    var hasSet = typeof Set !== "undefined";
    var hasProxies = typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined";
    var NOTHING = hasSymbol ? Symbol.for("immer-nothing") : (_ref = {}, _ref["immer-nothing"] = true, _ref);
    var DRAFTABLE = hasSymbol ? Symbol.for("immer-draftable") : "__$immer_draftable";
    var DRAFT_STATE = hasSymbol ? Symbol.for("immer-state") : "__$immer_state";
    var iteratorSymbol = typeof Symbol != "undefined" && Symbol.iterator || "@@iterator";
    var errors = {
      0: "Illegal state",
      1: "Immer drafts cannot have computed properties",
      2: "This object has been frozen and should not be mutated",
      3: function _2(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
      },
      4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
      5: "Immer forbids circular references",
      6: "The first or second argument to `produce` must be a function",
      7: "The third argument to `produce` must be a function or undefined",
      8: "First argument to `createDraft` must be a plain object, an array, or an immerable object",
      9: "First argument to `finishDraft` must be a draft returned by `createDraft`",
      10: "The given draft is already finalized",
      11: "Object.defineProperty() cannot be used on an Immer draft",
      12: "Object.setPrototypeOf() cannot be used on an Immer draft",
      13: "Immer only supports deleting array indices",
      14: "Immer only supports setting array indices and the 'length' property",
      15: function _2(path) {
        return "Cannot apply patch, path doesn't resolve: " + path;
      },
      16: 'Sets cannot have "replace" patches.',
      17: function _2(op) {
        return "Unsupported patch operation: " + op;
      },
      18: function _2(plugin) {
        return "The plugin for '" + plugin + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + plugin + "()` when initializing your application.";
      },
      20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",
      21: function _2(thing) {
        return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + thing + "'";
      },
      22: function _2(thing) {
        return "'current' expects a draft, got: " + thing;
      },
      23: function _2(thing) {
        return "'original' expects a draft, got: " + thing;
      },
      24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
    };
    function die(error) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      {
        var e2 = errors[error];
        var msg = !e2 ? "unknown error nr: " + error : typeof e2 === "function" ? e2.apply(null, args) : e2;
        throw new Error("[Immer] " + msg);
      }
    }
    function isDraft(value) {
      return !!value && !!value[DRAFT_STATE];
    }
    function isDraftable(value) {
      var _value$constructor;
      if (!value)
        return false;
      return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);
    }
    var objectCtorString = Object.prototype.constructor.toString();
    function isPlainObject(value) {
      if (!value || typeof value !== "object")
        return false;
      var proto = Object.getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
    }
    function original(value) {
      if (!isDraft(value))
        die(23, value);
      return value[DRAFT_STATE].base_;
    }
    var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function(obj) {
      return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
    } : (
      /* istanbul ignore next */
      Object.getOwnPropertyNames
    );
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
      var res = {};
      ownKeys(target).forEach(function(key) {
        res[key] = Object.getOwnPropertyDescriptor(target, key);
      });
      return res;
    };
    function each(obj, iter, enumerableOnly) {
      if (enumerableOnly === void 0) {
        enumerableOnly = false;
      }
      if (getArchtype(obj) === 0) {
        (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function(key) {
          if (!enumerableOnly || typeof key !== "symbol")
            iter(key, obj[key], obj);
        });
      } else {
        obj.forEach(function(entry, index) {
          return iter(index, entry, obj);
        });
      }
    }
    function getArchtype(thing) {
      var state = thing[DRAFT_STATE];
      return state ? state.type_ > 3 ? state.type_ - 4 : state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
    }
    function has(thing, prop) {
      return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
    }
    function get(thing, prop) {
      return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
    }
    function set(thing, propOrOldValue, value) {
      var t2 = getArchtype(thing);
      if (t2 === 2)
        thing.set(propOrOldValue, value);
      else if (t2 === 3) {
        thing.add(value);
      } else
        thing[propOrOldValue] = value;
    }
    function is(x2, y2) {
      if (x2 === y2) {
        return x2 !== 0 || 1 / x2 === 1 / y2;
      } else {
        return x2 !== x2 && y2 !== y2;
      }
    }
    function isMap(target) {
      return hasMap && target instanceof Map;
    }
    function isSet(target) {
      return hasSet && target instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base) {
      if (Array.isArray(base))
        return Array.prototype.slice.call(base);
      var descriptors = getOwnPropertyDescriptors(base);
      delete descriptors[DRAFT_STATE];
      var keys = ownKeys(descriptors);
      for (var i2 = 0; i2 < keys.length; i2++) {
        var key = keys[i2];
        var desc = descriptors[key];
        if (desc.writable === false) {
          desc.writable = true;
          desc.configurable = true;
        }
        if (desc.get || desc.set)
          descriptors[key] = {
            configurable: true,
            writable: true,
            enumerable: desc.enumerable,
            value: base[key]
          };
      }
      return Object.create(Object.getPrototypeOf(base), descriptors);
    }
    function freeze(obj, deep) {
      if (deep === void 0) {
        deep = false;
      }
      if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
      }
      Object.freeze(obj);
      if (deep)
        each(obj, function(key, value) {
          return freeze(value, true);
        }, true);
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    function isFrozen(obj) {
      if (obj == null || typeof obj !== "object")
        return true;
      return Object.isFrozen(obj);
    }
    var plugins = {};
    function getPlugin(pluginKey) {
      var plugin = plugins[pluginKey];
      if (!plugin) {
        die(18, pluginKey);
      }
      return plugin;
    }
    function loadPlugin(pluginKey, implementation) {
      if (!plugins[pluginKey])
        plugins[pluginKey] = implementation;
    }
    var currentScope;
    function getCurrentScope() {
      if (!currentScope)
        die(0);
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope) {
      leaveScope(scope);
      scope.drafts_.forEach(revokeDraft);
      scope.drafts_ = null;
    }
    function leaveScope(scope) {
      if (scope === currentScope) {
        currentScope = scope.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      var state = draft[DRAFT_STATE];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult(result, scope) {
      scope.unfinalizedDrafts_ = scope.drafts_.length;
      var baseDraft = scope.drafts_[0];
      var isReplaced = result !== void 0 && result !== baseDraft;
      if (!scope.immer_.useProxies_)
        getPlugin("ES5").willFinalizeES5_(scope, result, isReplaced);
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope);
          die(4);
        }
        if (isDraftable(result)) {
          result = finalize(scope, result);
          if (!scope.parent_)
            maybeFreeze(scope, result);
        }
        if (scope.patches_) {
          getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
        }
      } else {
        result = finalize(scope, baseDraft, []);
      }
      revokeScope(scope);
      if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value, path) {
      if (isFrozen(value))
        return value;
      var state = value[DRAFT_STATE];
      if (!state) {
        each(
          value,
          function(key, childValue) {
            return finalizeProperty(rootScope, state, value, key, childValue, path);
          },
          true
          // See #590, don't recurse into non-enumerable of non drafted objects
        );
        return value;
      }
      if (state.scope_ !== rootScope)
        return value;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        var result = (
          // For ES5, create a good copy from the draft first, with added keys and without deleted keys.
          state.type_ === 4 || state.type_ === 5 ? state.copy_ = shallowCopy(state.draft_) : state.copy_
        );
        var resultEach = result;
        var isSet2 = false;
        if (state.type_ === 3) {
          resultEach = new Set(result);
          result.clear();
          isSet2 = true;
        }
        each(resultEach, function(key, childValue) {
          return finalizeProperty(rootScope, state, result, key, childValue, path, isSet2);
        });
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
      if (childValue === targetObject)
        die(5);
      if (isDraft(childValue)) {
        var path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        var res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      } else if (targetIsSet) {
        targetObject.add(childValue);
      }
      if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        finalize(rootScope, childValue);
        if (!parentState || !parentState.scope_.parent_)
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope, value, deep) {
      if (deep === void 0) {
        deep = false;
      }
      if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
      }
    }
    function createProxyProxy(base, parent) {
      var isArray = Array.isArray(base);
      var state = {
        type_: isArray ? 1 : 0,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
      };
      var target = state;
      var traps = objectTraps;
      if (isArray) {
        target = [state];
        traps = arrayTraps;
      }
      var _Proxy$revocable = Proxy.revocable(target, traps), revoke = _Proxy$revocable.revoke, proxy = _Proxy$revocable.proxy;
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get: function get2(state, prop) {
        if (prop === DRAFT_STATE)
          return state;
        var source = latest(state);
        if (!has(source, prop)) {
          return readPropFromProto(state, source, prop);
        }
        var value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
          return value;
        }
        if (value === peek(state.base_, prop)) {
          prepareCopy(state);
          return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);
        }
        return value;
      },
      has: function has2(state, prop) {
        return prop in latest(state);
      },
      ownKeys: function ownKeys2(state) {
        return Reflect.ownKeys(latest(state));
      },
      set: function set2(state, prop, value) {
        var desc = getDescriptorFromProto(latest(state), prop);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
          desc.set.call(state.draft_, value);
          return true;
        }
        if (!state.modified_) {
          var current2 = peek(latest(state), prop);
          var currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];
          if (currentState && currentState.base_ === value) {
            state.copy_[prop] = value;
            state.assigned_[prop] = false;
            return true;
          }
          if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
          return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
      },
      deleteProperty: function deleteProperty(state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_[prop] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop];
        }
        if (state.copy_)
          delete state.copy_[prop];
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
        var owner = latest(state);
        var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop !== "length",
          enumerable: desc.enumerable,
          value: owner[prop]
        };
      },
      defineProperty: function defineProperty() {
        die(11);
      },
      getPrototypeOf: function getPrototypeOf(state) {
        return Object.getPrototypeOf(state.base_);
      },
      setPrototypeOf: function setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, function(key, fn) {
      arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop) {
      if (isNaN(parseInt(prop)))
        die(13);
      return arrayTraps.set.call(this, state, prop, void 0);
    };
    arrayTraps.set = function(state, prop, value) {
      if (prop !== "length" && isNaN(parseInt(prop)))
        die(14);
      return objectTraps.set.call(this, state[0], prop, value, state[0]);
    };
    function peek(draft, prop) {
      var state = draft[DRAFT_STATE];
      var source = state ? latest(state) : draft;
      return source[prop];
    }
    function readPropFromProto(state, source, prop) {
      var _desc$get;
      var desc = getDescriptorFromProto(source, prop);
      return desc ? "value" in desc ? desc.value : (
        // This is a very special case, if the prop is a getter defined by the
        // prototype, we should invoke it with the draft as context!
        (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_)
      ) : void 0;
    }
    function getDescriptorFromProto(source, prop) {
      if (!(prop in source))
        return void 0;
      var proto = Object.getPrototypeOf(source);
      while (proto) {
        var desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc)
          return desc;
        proto = Object.getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(state.base_);
      }
    }
    var Immer = function() {
      function Immer2(config) {
        var _this = this;
        this.useProxies_ = hasProxies;
        this.autoFreeze_ = true;
        this.produce = function(base, recipe, patchListener) {
          if (typeof base === "function" && typeof recipe !== "function") {
            var defaultBase = recipe;
            recipe = base;
            var self = _this;
            return function curriedProduce(base2) {
              var _this2 = this;
              if (base2 === void 0) {
                base2 = defaultBase;
              }
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              return self.produce(base2, function(draft) {
                var _recipe;
                return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));
              });
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          var result;
          if (isDraftable(base)) {
            var scope = enterScope(_this);
            var proxy = createProxy(_this, base, void 0);
            var hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope);
              else
                leaveScope(scope);
            }
            if (typeof Promise !== "undefined" && result instanceof Promise) {
              return result.then(function(result2) {
                usePatchesInScope(scope, patchListener);
                return processResult(result2, scope);
              }, function(error) {
                revokeScope(scope);
                throw error;
              });
            }
            usePatchesInScope(scope, patchListener);
            return processResult(result, scope);
          } else if (!base || typeof base !== "object") {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING)
              result = void 0;
            if (_this.autoFreeze_)
              freeze(result, true);
            if (patchListener) {
              var p = [];
              var ip = [];
              getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
              patchListener(p, ip);
            }
            return result;
          } else
            die(21, base);
        };
        this.produceWithPatches = function(base, recipe) {
          if (typeof base === "function") {
            return function(state) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              return _this.produceWithPatches(state, function(draft) {
                return base.apply(void 0, [draft].concat(args));
              });
            };
          }
          var patches, inversePatches;
          var result = _this.produce(base, recipe, function(p, ip) {
            patches = p;
            inversePatches = ip;
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then(function(nextState) {
              return [nextState, patches, inversePatches];
            });
          }
          return [result, patches, inversePatches];
        };
        if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === "boolean")
          this.setUseProxies(config.useProxies);
        if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean")
          this.setAutoFreeze(config.autoFreeze);
      }
      var _proto = Immer2.prototype;
      _proto.createDraft = function createDraft2(base) {
        if (!isDraftable(base))
          die(8);
        if (isDraft(base))
          base = current(base);
        var scope = enterScope(this);
        var proxy = createProxy(this, base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope);
        return proxy;
      };
      _proto.finishDraft = function finishDraft2(draft, patchListener) {
        var state = draft && draft[DRAFT_STATE];
        {
          if (!state || !state.isManual_)
            die(9);
          if (state.finalized_)
            die(10);
        }
        var scope = state.scope_;
        usePatchesInScope(scope, patchListener);
        return processResult(void 0, scope);
      };
      _proto.setAutoFreeze = function setAutoFreeze2(value) {
        this.autoFreeze_ = value;
      };
      _proto.setUseProxies = function setUseProxies2(value) {
        if (value && !hasProxies) {
          die(20);
        }
        this.useProxies_ = value;
      };
      _proto.applyPatches = function applyPatches2(base, patches) {
        var i2;
        for (i2 = patches.length - 1; i2 >= 0; i2--) {
          var patch = patches[i2];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i2 > -1) {
          patches = patches.slice(i2 + 1);
        }
        var applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(base, function(draft) {
          return applyPatchesImpl(draft, patches);
        });
      };
      return Immer2;
    }();
    function createProxy(immer2, value, parent) {
      var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : immer2.useProxies_ ? createProxyProxy(value, parent) : getPlugin("ES5").createES5Proxy_(value, parent);
      var scope = parent ? parent.scope_ : getCurrentScope();
      scope.drafts_.push(draft);
      return draft;
    }
    function current(value) {
      if (!isDraft(value))
        die(22, value);
      return currentImpl(value);
    }
    function currentImpl(value) {
      if (!isDraftable(value))
        return value;
      var state = value[DRAFT_STATE];
      var copy;
      var archType = getArchtype(value);
      if (state) {
        if (!state.modified_ && (state.type_ < 4 || !getPlugin("ES5").hasChanges_(state)))
          return state.base_;
        state.finalized_ = true;
        copy = copyHelper(value, archType);
        state.finalized_ = false;
      } else {
        copy = copyHelper(value, archType);
      }
      each(copy, function(key, childValue) {
        if (state && get(state.base_, key) === childValue)
          return;
        set(copy, key, currentImpl(childValue));
      });
      return archType === 3 ? new Set(copy) : copy;
    }
    function copyHelper(value, archType) {
      switch (archType) {
        case 2:
          return new Map(value);
        case 3:
          return Array.from(value);
      }
      return shallowCopy(value);
    }
    function enableES5() {
      function willFinalizeES5_(scope, result, isReplaced) {
        if (!isReplaced) {
          if (scope.patches_) {
            markChangesRecursively(scope.drafts_[0]);
          }
          markChangesSweep(scope.drafts_);
        } else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {
          markChangesSweep(scope.drafts_);
        }
      }
      function createES5Draft(isArray, base) {
        if (isArray) {
          var draft = new Array(base.length);
          for (var i2 = 0; i2 < base.length; i2++) {
            Object.defineProperty(draft, "" + i2, proxyProperty(i2, true));
          }
          return draft;
        } else {
          var _descriptors = getOwnPropertyDescriptors(base);
          delete _descriptors[DRAFT_STATE];
          var keys = ownKeys(_descriptors);
          for (var _i = 0; _i < keys.length; _i++) {
            var key = keys[_i];
            _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);
          }
          return Object.create(Object.getPrototypeOf(base), _descriptors);
        }
      }
      function createES5Proxy_(base, parent) {
        var isArray = Array.isArray(base);
        var draft = createES5Draft(isArray, base);
        var state = {
          type_: isArray ? 5 : 4,
          scope_: parent ? parent.scope_ : getCurrentScope(),
          modified_: false,
          finalized_: false,
          assigned_: {},
          parent_: parent,
          // base is the object we are drafting
          base_: base,
          // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)
          draft_: draft,
          copy_: null,
          revoked_: false,
          isManual_: false
        };
        Object.defineProperty(draft, DRAFT_STATE, {
          value: state,
          // enumerable: false <- the default
          writable: true
        });
        return draft;
      }
      var descriptors = {};
      function proxyProperty(prop, enumerable) {
        var desc = descriptors[prop];
        if (desc) {
          desc.enumerable = enumerable;
        } else {
          descriptors[prop] = desc = {
            configurable: true,
            enumerable,
            get: function get2() {
              var state = this[DRAFT_STATE];
              assertUnrevoked(state);
              return objectTraps.get(state, prop);
            },
            set: function set2(value) {
              var state = this[DRAFT_STATE];
              assertUnrevoked(state);
              objectTraps.set(state, prop, value);
            }
          };
        }
        return desc;
      }
      function markChangesSweep(drafts) {
        for (var i2 = drafts.length - 1; i2 >= 0; i2--) {
          var state = drafts[i2][DRAFT_STATE];
          if (!state.modified_) {
            switch (state.type_) {
              case 5:
                if (hasArrayChanges(state))
                  markChanged(state);
                break;
              case 4:
                if (hasObjectChanges(state))
                  markChanged(state);
                break;
            }
          }
        }
      }
      function markChangesRecursively(object) {
        if (!object || typeof object !== "object")
          return;
        var state = object[DRAFT_STATE];
        if (!state)
          return;
        var base_ = state.base_, draft_ = state.draft_, assigned_ = state.assigned_, type_ = state.type_;
        if (type_ === 4) {
          each(draft_, function(key) {
            if (key === DRAFT_STATE)
              return;
            if (base_[key] === void 0 && !has(base_, key)) {
              assigned_[key] = true;
              markChanged(state);
            } else if (!assigned_[key]) {
              markChangesRecursively(draft_[key]);
            }
          });
          each(base_, function(key) {
            if (draft_[key] === void 0 && !has(draft_, key)) {
              assigned_[key] = false;
              markChanged(state);
            }
          });
        } else if (type_ === 5) {
          if (hasArrayChanges(state)) {
            markChanged(state);
            assigned_.length = true;
          }
          if (draft_.length < base_.length) {
            for (var i2 = draft_.length; i2 < base_.length; i2++) {
              assigned_[i2] = false;
            }
          } else {
            for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {
              assigned_[_i2] = true;
            }
          }
          var min = Math.min(draft_.length, base_.length);
          for (var _i3 = 0; _i3 < min; _i3++) {
            if (!draft_.hasOwnProperty(_i3)) {
              assigned_[_i3] = true;
            }
            if (assigned_[_i3] === void 0)
              markChangesRecursively(draft_[_i3]);
          }
        }
      }
      function hasObjectChanges(state) {
        var base_ = state.base_, draft_ = state.draft_;
        var keys = ownKeys(draft_);
        for (var i2 = keys.length - 1; i2 >= 0; i2--) {
          var key = keys[i2];
          if (key === DRAFT_STATE)
            continue;
          var baseValue = base_[key];
          if (baseValue === void 0 && !has(base_, key)) {
            return true;
          } else {
            var value = draft_[key];
            var _state = value && value[DRAFT_STATE];
            if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {
              return true;
            }
          }
        }
        var baseIsDraft = !!base_[DRAFT_STATE];
        return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1);
      }
      function hasArrayChanges(state) {
        var draft_ = state.draft_;
        if (draft_.length !== state.base_.length)
          return true;
        var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1);
        if (descriptor && !descriptor.get)
          return true;
        for (var i2 = 0; i2 < draft_.length; i2++) {
          if (!draft_.hasOwnProperty(i2))
            return true;
        }
        return false;
      }
      function hasChanges_(state) {
        return state.type_ === 4 ? hasObjectChanges(state) : hasArrayChanges(state);
      }
      function assertUnrevoked(state) {
        if (state.revoked_)
          die(3, JSON.stringify(latest(state)));
      }
      loadPlugin("ES5", {
        createES5Proxy_,
        willFinalizeES5_,
        hasChanges_
      });
    }
    function enablePatches() {
      var REPLACE = "replace";
      var ADD = "add";
      var REMOVE = "remove";
      function generatePatches_(state, basePath, patches, inversePatches) {
        switch (state.type_) {
          case 0:
          case 4:
          case 2:
            return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
          case 5:
          case 1:
            return generateArrayPatches(state, basePath, patches, inversePatches);
          case 3:
            return generateSetPatches(state, basePath, patches, inversePatches);
        }
      }
      function generateArrayPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, assigned_ = state.assigned_;
        var copy_ = state.copy_;
        if (copy_.length < base_.length) {
          var _ref2 = [copy_, base_];
          base_ = _ref2[0];
          copy_ = _ref2[1];
          var _ref22 = [inversePatches, patches];
          patches = _ref22[0];
          inversePatches = _ref22[1];
        }
        for (var i2 = 0; i2 < base_.length; i2++) {
          if (assigned_[i2] && copy_[i2] !== base_[i2]) {
            var path = basePath.concat([i2]);
            patches.push({
              op: REPLACE,
              path,
              // Need to maybe clone it, as it can in fact be the original value
              // due to the base/copy inversion at the start of this function
              value: clonePatchValueIfNeeded(copy_[i2])
            });
            inversePatches.push({
              op: REPLACE,
              path,
              value: clonePatchValueIfNeeded(base_[i2])
            });
          }
        }
        for (var _i = base_.length; _i < copy_.length; _i++) {
          var _path = basePath.concat([_i]);
          patches.push({
            op: ADD,
            path: _path,
            // Need to maybe clone it, as it can in fact be the original value
            // due to the base/copy inversion at the start of this function
            value: clonePatchValueIfNeeded(copy_[_i])
          });
        }
        if (base_.length < copy_.length) {
          inversePatches.push({
            op: REPLACE,
            path: basePath.concat(["length"]),
            value: base_.length
          });
        }
      }
      function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        each(state.assigned_, function(key, assignedValue) {
          var origValue = get(base_, key);
          var value = get(copy_, key);
          var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
          if (origValue === value && op === REPLACE)
            return;
          var path = basePath.concat(key);
          patches.push(op === REMOVE ? {
            op,
            path
          } : {
            op,
            path,
            value
          });
          inversePatches.push(op === ADD ? {
            op: REMOVE,
            path
          } : op === REMOVE ? {
            op: ADD,
            path,
            value: clonePatchValueIfNeeded(origValue)
          } : {
            op: REPLACE,
            path,
            value: clonePatchValueIfNeeded(origValue)
          });
        });
      }
      function generateSetPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        var i2 = 0;
        base_.forEach(function(value) {
          if (!copy_.has(value)) {
            var path = basePath.concat([i2]);
            patches.push({
              op: REMOVE,
              path,
              value
            });
            inversePatches.unshift({
              op: ADD,
              path,
              value
            });
          }
          i2++;
        });
        i2 = 0;
        copy_.forEach(function(value) {
          if (!base_.has(value)) {
            var path = basePath.concat([i2]);
            patches.push({
              op: ADD,
              path,
              value
            });
            inversePatches.unshift({
              op: REMOVE,
              path,
              value
            });
          }
          i2++;
        });
      }
      function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
        patches.push({
          op: REPLACE,
          path: [],
          value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches.push({
          op: REPLACE,
          path: [],
          value: baseValue
        });
      }
      function applyPatches_(draft, patches) {
        patches.forEach(function(patch) {
          var path = patch.path, op = patch.op;
          var base = draft;
          for (var i2 = 0; i2 < path.length - 1; i2++) {
            var parentType = getArchtype(base);
            var p = path[i2];
            if (typeof p !== "string" && typeof p !== "number") {
              p = "" + p;
            }
            if ((parentType === 0 || parentType === 1) && (p === "__proto__" || p === "constructor"))
              die(24);
            if (typeof base === "function" && p === "prototype")
              die(24);
            base = get(base, p);
            if (typeof base !== "object")
              die(15, path.join("/"));
          }
          var type = getArchtype(base);
          var value = deepClonePatchValue(patch.value);
          var key = path[path.length - 1];
          switch (op) {
            case REPLACE:
              switch (type) {
                case 2:
                  return base.set(key, value);
                case 3:
                  die(16);
                default:
                  return base[key] = value;
              }
            case ADD:
              switch (type) {
                case 1:
                  return key === "-" ? base.push(value) : base.splice(key, 0, value);
                case 2:
                  return base.set(key, value);
                case 3:
                  return base.add(value);
                default:
                  return base[key] = value;
              }
            case REMOVE:
              switch (type) {
                case 1:
                  return base.splice(key, 1);
                case 2:
                  return base.delete(key);
                case 3:
                  return base.delete(patch.value);
                default:
                  return delete base[key];
              }
            default:
              die(17, op);
          }
        });
        return draft;
      }
      function deepClonePatchValue(obj) {
        if (!isDraftable(obj))
          return obj;
        if (Array.isArray(obj))
          return obj.map(deepClonePatchValue);
        if (isMap(obj))
          return new Map(Array.from(obj.entries()).map(function(_ref3) {
            var k2 = _ref3[0], v2 = _ref3[1];
            return [k2, deepClonePatchValue(v2)];
          }));
        if (isSet(obj))
          return new Set(Array.from(obj).map(deepClonePatchValue));
        var cloned = Object.create(Object.getPrototypeOf(obj));
        for (var key in obj) {
          cloned[key] = deepClonePatchValue(obj[key]);
        }
        if (has(obj, DRAFTABLE))
          cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
      }
      function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) {
          return deepClonePatchValue(obj);
        } else
          return obj;
      }
      loadPlugin("Patches", {
        applyPatches_,
        generatePatches_,
        generateReplacementPatches_
      });
    }
    function enableMapSet() {
      var _extendStatics = function extendStatics(d2, b2) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p in b3) {
            if (b3.hasOwnProperty(p))
              d3[p] = b3[p];
          }
        };
        return _extendStatics(d2, b2);
      };
      function __extends(d2, b2) {
        _extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = // @ts-ignore
        (__.prototype = b2.prototype, new __());
      }
      var DraftMap = function(_super) {
        __extends(DraftMap2, _super);
        function DraftMap2(target, parent) {
          this[DRAFT_STATE] = {
            type_: 2,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            assigned_: void 0,
            base_: target,
            draft_: this,
            isManual_: false,
            revoked_: false
          };
          return this;
        }
        var p = DraftMap2.prototype;
        Object.defineProperty(p, "size", {
          get: function get2() {
            return latest(this[DRAFT_STATE]).size;
          }
          // enumerable: false,
          // configurable: true
        });
        p.has = function(key) {
          return latest(this[DRAFT_STATE]).has(key);
        };
        p.set = function(key, value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!latest(state).has(key) || latest(state).get(key) !== value) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_.set(key, true);
            state.copy_.set(key, value);
            state.assigned_.set(key, true);
          }
          return this;
        };
        p.delete = function(key) {
          if (!this.has(key)) {
            return false;
          }
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareMapCopy(state);
          markChanged(state);
          if (state.base_.has(key)) {
            state.assigned_.set(key, false);
          } else {
            state.assigned_.delete(key);
          }
          state.copy_.delete(key);
          return true;
        };
        p.clear = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareMapCopy(state);
            markChanged(state);
            state.assigned_ = /* @__PURE__ */ new Map();
            each(state.base_, function(key) {
              state.assigned_.set(key, false);
            });
            state.copy_.clear();
          }
        };
        p.forEach = function(cb, thisArg) {
          var _this = this;
          var state = this[DRAFT_STATE];
          latest(state).forEach(function(_value, key, _map) {
            cb.call(thisArg, _this.get(key), key, _this);
          });
        };
        p.get = function(key) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          var value = latest(state).get(key);
          if (state.finalized_ || !isDraftable(value)) {
            return value;
          }
          if (value !== state.base_.get(key)) {
            return value;
          }
          var draft = createProxy(state.scope_.immer_, value, state);
          prepareMapCopy(state);
          state.copy_.set(key, draft);
          return draft;
        };
        p.keys = function() {
          return latest(this[DRAFT_STATE]).keys();
        };
        p.values = function() {
          var _this2 = this, _ref2;
          var iterator = this.keys();
          return _ref2 = {}, _ref2[iteratorSymbol] = function() {
            return _this2.values();
          }, _ref2.next = function next() {
            var r2 = iterator.next();
            if (r2.done)
              return r2;
            var value = _this2.get(r2.value);
            return {
              done: false,
              value
            };
          }, _ref2;
        };
        p.entries = function() {
          var _this3 = this, _ref2;
          var iterator = this.keys();
          return _ref2 = {}, _ref2[iteratorSymbol] = function() {
            return _this3.entries();
          }, _ref2.next = function next() {
            var r2 = iterator.next();
            if (r2.done)
              return r2;
            var value = _this3.get(r2.value);
            return {
              done: false,
              value: [r2.value, value]
            };
          }, _ref2;
        };
        p[iteratorSymbol] = function() {
          return this.entries();
        };
        return DraftMap2;
      }(Map);
      function proxyMap_(target, parent) {
        return new DraftMap(target, parent);
      }
      function prepareMapCopy(state) {
        if (!state.copy_) {
          state.assigned_ = /* @__PURE__ */ new Map();
          state.copy_ = new Map(state.base_);
        }
      }
      var DraftSet = function(_super) {
        __extends(DraftSet2, _super);
        function DraftSet2(target, parent) {
          this[DRAFT_STATE] = {
            type_: 3,
            parent_: parent,
            scope_: parent ? parent.scope_ : getCurrentScope(),
            modified_: false,
            finalized_: false,
            copy_: void 0,
            base_: target,
            draft_: this,
            drafts_: /* @__PURE__ */ new Map(),
            revoked_: false,
            isManual_: false
          };
          return this;
        }
        var p = DraftSet2.prototype;
        Object.defineProperty(p, "size", {
          get: function get2() {
            return latest(this[DRAFT_STATE]).size;
          }
          // enumerable: true,
        });
        p.has = function(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!state.copy_) {
            return state.base_.has(value);
          }
          if (state.copy_.has(value))
            return true;
          if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
            return true;
          return false;
        };
        p.add = function(value) {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (!this.has(value)) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.add(value);
          }
          return this;
        };
        p.delete = function(value) {
          if (!this.has(value)) {
            return false;
          }
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          markChanged(state);
          return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (
            /* istanbul ignore next */
            false
          ));
        };
        p.clear = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          if (latest(state).size) {
            prepareSetCopy(state);
            markChanged(state);
            state.copy_.clear();
          }
        };
        p.values = function() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.values();
        };
        p.entries = function entries() {
          var state = this[DRAFT_STATE];
          assertUnrevoked(state);
          prepareSetCopy(state);
          return state.copy_.entries();
        };
        p.keys = function() {
          return this.values();
        };
        p[iteratorSymbol] = function() {
          return this.values();
        };
        p.forEach = function forEach(cb, thisArg) {
          var iterator = this.values();
          var result = iterator.next();
          while (!result.done) {
            cb.call(thisArg, result.value, result.value, this);
            result = iterator.next();
          }
        };
        return DraftSet2;
      }(Set);
      function proxySet_(target, parent) {
        return new DraftSet(target, parent);
      }
      function prepareSetCopy(state) {
        if (!state.copy_) {
          state.copy_ = /* @__PURE__ */ new Set();
          state.base_.forEach(function(value) {
            if (isDraftable(value)) {
              var draft = createProxy(state.scope_.immer_, value, state);
              state.drafts_.set(value, draft);
              state.copy_.add(draft);
            } else {
              state.copy_.add(value);
            }
          });
        }
      }
      function assertUnrevoked(state) {
        if (state.revoked_)
          die(3, JSON.stringify(latest(state)));
      }
      loadPlugin("MapSet", {
        proxyMap_,
        proxySet_
      });
    }
    function enableAllPlugins() {
      enableES5();
      enableMapSet();
      enablePatches();
    }
    var immer = new Immer();
    var produce = immer.produce;
    var produceWithPatches = immer.produceWithPatches.bind(immer);
    var setAutoFreeze = immer.setAutoFreeze.bind(immer);
    var setUseProxies = immer.setUseProxies.bind(immer);
    var applyPatches = immer.applyPatches.bind(immer);
    var createDraft = immer.createDraft.bind(immer);
    var finishDraft = immer.finishDraft.bind(immer);
    function castDraft(value) {
      return value;
    }
    function castImmutable(value) {
      return value;
    }
    exports.Immer = Immer;
    exports.applyPatches = applyPatches;
    exports.castDraft = castDraft;
    exports.castImmutable = castImmutable;
    exports.createDraft = createDraft;
    exports.current = current;
    exports.default = produce;
    exports.enableAllPlugins = enableAllPlugins;
    exports.enableES5 = enableES5;
    exports.enableMapSet = enableMapSet;
    exports.enablePatches = enablePatches;
    exports.finishDraft = finishDraft;
    exports.freeze = freeze;
    exports.immerable = DRAFTABLE;
    exports.isDraft = isDraft;
    exports.isDraftable = isDraftable;
    exports.nothing = NOTHING;
    exports.original = original;
    exports.produce = produce;
    exports.produceWithPatches = produceWithPatches;
    exports.setAutoFreeze = setAutoFreeze;
    exports.setUseProxies = setUseProxies;
  }
});

// node_modules/immer/dist/index.js
var require_dist = __commonJS({
  "node_modules/immer/dist/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_immer_cjs_development();
    }
  }
});

// node_modules/@jaredreisinger/react-crossword/dist/types.js
var require_types = __commonJS({
  "node_modules/@jaredreisinger/react-crossword/dist/types.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cluesInputShapeOriginal = exports.clueShapeOriginal = void 0;
    var prop_types_1 = __importDefault(require_prop_types());
    var clueInputPropsOriginal = {
      /** The clue to display */
      clue: prop_types_1.default.string.isRequired,
      /** The answer for the clue */
      answer: prop_types_1.default.string.isRequired,
      /** The 0-based row on which the answer begins */
      row: prop_types_1.default.number.isRequired,
      /** The 0-based column on which the answer begins */
      col: prop_types_1.default.number.isRequired
    };
    exports.clueShapeOriginal = prop_types_1.default.shape(clueInputPropsOriginal);
    exports.cluesInputShapeOriginal = prop_types_1.default.shape({
      /** "across" clues and answers */
      across: prop_types_1.default.objectOf(exports.clueShapeOriginal.isRequired).isRequired,
      /** "down" clues and answers */
      down: prop_types_1.default.objectOf(exports.clueShapeOriginal.isRequired).isRequired
    });
  }
});

// node_modules/@jaredreisinger/react-crossword/dist/util.js
var require_util = __commonJS({
  "node_modules/@jaredreisinger/react-crossword/dist/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findCorrectAnswers = exports.deserializeGuesses = exports.loadGuesses = exports.serializeGuesses = exports.saveGuesses = exports.clearGuesses = exports.byNumber = exports.createGridData = exports.fillClues = exports.createEmptyGrid = exports.calculateExtents = exports.otherDirection = exports.isAcross = exports.bothDirections = void 0;
    var directionInfo = {
      across: {
        primary: "col",
        orthogonal: "row"
      },
      down: {
        primary: "row",
        orthogonal: "col"
      }
    };
    exports.bothDirections = Object.keys(directionInfo);
    function isAcross(direction) {
      return direction === "across";
    }
    exports.isAcross = isAcross;
    function otherDirection(direction) {
      return isAcross(direction) ? "down" : "across";
    }
    exports.otherDirection = otherDirection;
    function calculateExtents(data, direction) {
      const dir = directionInfo[direction];
      let primaryMax = 0;
      let orthogonalMax = 0;
      Object.entries(data[direction]).forEach(([, info]) => {
        const primary = info[dir.primary] + info.answer.length - 1;
        if (primary > primaryMax) {
          primaryMax = primary;
        }
        const orthogonal = info[dir.orthogonal];
        if (orthogonal > orthogonalMax) {
          orthogonalMax = orthogonal;
        }
      });
      const rowColMax = {
        row: 0,
        col: 0
      };
      rowColMax[dir.primary] = primaryMax;
      rowColMax[dir.orthogonal] = orthogonalMax;
      return rowColMax;
    }
    exports.calculateExtents = calculateExtents;
    function createEmptyGrid(rows, cols) {
      const gridData = Array(rows);
      for (let r2 = 0; r2 < rows; r2++) {
        gridData[r2] = Array(cols);
        for (let c2 = 0; c2 < cols; c2++) {
          gridData[r2][c2] = {
            // ...emptyCellData,
            row: r2,
            col: c2,
            used: false
          };
        }
      }
      return gridData;
    }
    exports.createEmptyGrid = createEmptyGrid;
    function fillClues(gridData, clues, data, direction) {
      const dir = directionInfo[direction];
      Object.entries(data[direction]).forEach(([number, info]) => {
        const { row: rowStart, col: colStart, clue, answer } = info;
        for (let i2 = 0; i2 < answer.length; i2++) {
          const row = rowStart + (dir.primary === "row" ? i2 : 0);
          const col = colStart + (dir.primary === "col" ? i2 : 0);
          const cellData = gridData[row][col];
          cellData.used = true;
          cellData.answer = answer[i2];
          cellData[direction] = number;
          if (i2 === 0) {
            cellData.number = number;
          }
        }
        clues[direction].push({
          number,
          clue,
          answer,
          col: colStart,
          row: rowStart
        });
      });
      clues[direction].sort(byNumber);
    }
    exports.fillClues = fillClues;
    function createGridData(data, allowNonSquare) {
      const acrossMax = calculateExtents(data, "across");
      const downMax = calculateExtents(data, "down");
      let rows = Math.max(acrossMax.row, downMax.row) + 1;
      let cols = Math.max(acrossMax.col, downMax.col) + 1;
      if (!allowNonSquare) {
        const size = Math.max(rows, cols);
        rows = size;
        cols = size;
      }
      const gridData = createEmptyGrid(rows, cols);
      const clues = {
        across: [],
        down: []
      };
      fillClues(gridData, clues, data, "across");
      fillClues(gridData, clues, data, "down");
      return { rows, cols, gridData, clues };
    }
    exports.createGridData = createGridData;
    function byNumber(a2, b2) {
      const aNum = Number.parseInt(a2.number, 10);
      const bNum = Number.parseInt(b2.number, 10);
      return aNum - bNum;
    }
    exports.byNumber = byNumber;
    function clearGuesses(storageKey) {
      if (!window.localStorage) {
        return;
      }
      window.localStorage.removeItem(storageKey);
    }
    exports.clearGuesses = clearGuesses;
    function saveGuesses(gridData, storageKey) {
      const { localStorage } = window;
      if (!localStorage) {
        return;
      }
      const guesses = serializeGuesses(gridData);
      const saveData = {
        date: Date.now(),
        guesses
      };
      localStorage.setItem(storageKey, JSON.stringify(saveData));
    }
    exports.saveGuesses = saveGuesses;
    function serializeGuesses(gridData) {
      const guesses = gridData.reduce((memo, row, r2) => row.reduce((memoInner, cellData, c2) => {
        var _a;
        const { guess } = cellData;
        if (guess !== "") {
          memoInner[`${r2}_${c2}`] = (_a = cellData.guess) !== null && _a !== void 0 ? _a : "";
        }
        return memoInner;
      }, memo), {});
      return guesses;
    }
    exports.serializeGuesses = serializeGuesses;
    function loadGuesses(gridData, storageKey) {
      const { localStorage } = window;
      if (!localStorage) {
        return;
      }
      const saveRaw = localStorage.getItem(storageKey);
      if (!saveRaw) {
        return;
      }
      const saveData = JSON.parse(saveRaw);
      deserializeGuesses(gridData, saveData.guesses);
    }
    exports.loadGuesses = loadGuesses;
    function deserializeGuesses(gridData, guesses) {
      Object.entries(guesses).forEach(([key, val]) => {
        const [rStr, cStr] = key.split("_");
        const r2 = parseInt(rStr, 10);
        const c2 = parseInt(cStr, 10);
        if (r2 <= gridData.length - 1 && c2 <= gridData[0].length - 1) {
          gridData[r2][c2].guess = val;
        }
      });
    }
    exports.deserializeGuesses = deserializeGuesses;
    function findCorrectAnswers(data, gridData) {
      const correctAnswers = [];
      exports.bothDirections.forEach((direction) => {
        const across = isAcross(direction);
        Object.entries(data[direction]).forEach(([num, info]) => {
          const { row, col } = info;
          let correct = true;
          for (let i2 = 0; i2 < info.answer.length; i2++) {
            const r2 = across ? row : row + i2;
            const c2 = across ? col + i2 : col;
            if (gridData[r2][c2].guess !== info.answer[i2]) {
              correct = false;
              break;
            }
          }
          if (correct) {
            correctAnswers.push([direction, num, info.answer]);
          }
        });
      });
      return correctAnswers;
    }
    exports.findCorrectAnswers = findCorrectAnswers;
  }
});

// node_modules/@jaredreisinger/react-crossword/dist/CrosswordProvider.js
var require_CrosswordProvider = __commonJS({
  "node_modules/@jaredreisinger/react-crossword/dist/CrosswordProvider.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crosswordProviderPropTypes = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = __importStar(require_react());
    var prop_types_1 = __importDefault(require_prop_types());
    var immer_1 = __importDefault(require_dist());
    var styled_components_1 = (init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports));
    var context_1 = require_context();
    var types_1 = require_types();
    var util_1 = require_util();
    var defaultStorageKey = "guesses";
    exports.crosswordProviderPropTypes = {
      /**
       * clue/answer data; see <a
       * href="#/Configuration%20and%20customization/Clue%20input%20format">Clue
       * input format</a> for details.
       */
      data: types_1.cluesInputShapeOriginal.isRequired,
      /** presentation values for the crossword; these override any values coming from a parent ThemeProvider context. */
      theme: prop_types_1.default.shape({
        /**
         * whether to allow a non-square rendering
         * @since 5.1.0
         */
        allowNonSquare: prop_types_1.default.bool,
        /** browser-width at which the clues go from showing beneath the grid to showing beside the grid */
        columnBreakpoint: prop_types_1.default.string,
        /** overall background color (fill) for the crossword grid; can be `'transparent'` to show through a page background image */
        gridBackground: prop_types_1.default.string,
        /**  background for an answer cell */
        cellBackground: prop_types_1.default.string,
        /** border for an answer cell */
        cellBorder: prop_types_1.default.string,
        /** color for answer text (entered by the player) */
        textColor: prop_types_1.default.string,
        /** color for the across/down numbers in the grid */
        numberColor: prop_types_1.default.string,
        /** background color for the cell with focus, the one that the player is typing into */
        focusBackground: prop_types_1.default.string,
        /**
         * background color for the cells in the answer the player is working on,
         * helps indicate in which direction focus will be moving; also used as a
         * background on the active clue
         */
        highlightBackground: prop_types_1.default.string
      }),
      /** whether to use browser storage to persist the player's work-in-progress */
      useStorage: prop_types_1.default.bool,
      /**
       * a custom storage key to use for persistence; defaults to "guesses" when not
       * provided
       */
      storageKey: prop_types_1.default.string,
      /**
       * callback function that fires when a player completes an answer, whether
       * correct or not; called with `(direction, number, correct, answer)`
       * arguments, where `direction` is `'across'` or `'down'`, `number` is the
       * clue number as text (like `'1'`), `correct` is whether the guessed answer
       * is correct and `answer` is the (actual and correct) answer itself
       *
       * @since 4.3.0
       */
      onAnswerComplete: prop_types_1.default.func,
      /**
       * callback function that fires when a player answers a clue correctly; called
       * with `(direction, number, answer)` arguments, where `direction` is
       * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),
       * and `answer` is the answer itself
       *
       * @since 4.3.0; replacing `onCorrect` (to reduce ambiguity)
       */
      onAnswerCorrect: prop_types_1.default.func,
      /**
       * callback function that fires when a player answers a clue correctly; called
       * with `(direction, number, answer)` arguments, where `direction` is
       * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),
       * and `answer` is the answer itself
       *
       * @deprecated 4.3.0; being replaced by `onAnswerCorrect` (to reduce
       * ambiguity)
       */
      onCorrect: prop_types_1.default.func,
      /**
       * callback function that fires when a player answers a clue *in*correctly;
       * called with `(direction, number, answer)` arguments, where `direction` is
       * `'across'` or `'down'`, `number` is the clue number as text (like `'1'`),
       * and `answer` is the (actual and correct) answer itself
       *
       * @since 4.3.0
       */
      onAnswerIncorrect: prop_types_1.default.func,
      /**
       * callback function that's called when a crossword is loaded, to batch up
       * correct answers loaded from storage; passed an array of the same values
       * that `onCorrect` would recieve
       */
      onLoadedCorrect: prop_types_1.default.func,
      /**
       * callback function that's called when the overall crossword is complete,
       * whether correct or not; called with `(correct)` argument, a boolean which
       * indicates whether the crossword is correct or not.
       */
      onCrosswordComplete: prop_types_1.default.func,
      /**
       * callback function that's called when the overall crossword is completely
       * correct (or not)
       *
       * NOTE: this will be deprecated for `onCrosswordComplete` in the future.
       */
      onCrosswordCorrect: prop_types_1.default.func,
      /**
       * callback function called when a cell changes (e.g. when the user types a
       * letter); called with `(row, col, char)` arguments, where the `row` and
       * `column` are the 0-based position of the cell, and `char` is the character
       * typed (already massaged into upper-case)
       */
      onCellChange: prop_types_1.default.func,
      /**
       * callback function called when a clue is selected
       */
      onClueSelected: prop_types_1.default.func,
      children: prop_types_1.default.node
    };
    var defaultTheme = {
      allowNonSquare: false,
      columnBreakpoint: "768px",
      gridBackground: "rgb(0,0,0)",
      cellBackground: "rgb(255,255,255)",
      cellBorder: "rgb(0,0,0)",
      textColor: "rgb(0,0,0)",
      numberColor: "rgba(0,0,0, 0.25)",
      focusBackground: "rgb(255,255,0)",
      highlightBackground: "rgb(255,255,204)"
    };
    var CrosswordProvider = react_1.default.forwardRef(({ data, theme, onAnswerComplete, onAnswerCorrect, onCorrect, onAnswerIncorrect, onLoadedCorrect, onCrosswordComplete, onCrosswordCorrect, onCellChange, onClueSelected, useStorage, storageKey, children }, ref) => {
      const contextTheme = (0, react_1.useContext)(styled_components_1.ThemeContext);
      const finalTheme = (0, react_1.useMemo)(() => Object.assign(Object.assign(Object.assign({}, defaultTheme), contextTheme), theme), [contextTheme, theme]);
      const { rows, cols, gridData: masterGridData, clues: masterClues } = (0, react_1.useMemo)(() => {
        var _a;
        return (0, util_1.createGridData)(data, (_a = finalTheme.allowNonSquare) !== null && _a !== void 0 ? _a : false);
      }, [data, finalTheme.allowNonSquare]);
      const [gridData, setGridData] = (0, react_1.useState)([]);
      const [clues, setClues] = (0, react_1.useState)();
      const registeredFocusHandler = (0, react_1.useRef)(null);
      const [focused, setFocused] = (0, react_1.useState)(false);
      const [focusedRow, setFocusedRow] = (0, react_1.useState)(0);
      const [focusedCol, setFocusedCol] = (0, react_1.useState)(0);
      const [currentDirection, setCurrentDirection] = (0, react_1.useState)("across");
      const [currentNumber, setCurrentNumber] = (0, react_1.useState)("1");
      const [bulkChange, setBulkChange] = (0, react_1.useState)(null);
      const [checkQueue, setCheckQueue] = (0, react_1.useState)([]);
      const getCellData = (0, react_1.useCallback)((row, col) => {
        if (row >= 0 && row < rows && col >= 0 && col < cols) {
          return gridData[row][col];
        }
        return { row, col, used: false, outOfBounds: true };
      }, [cols, gridData, rows]);
      const setCellCharacter = (0, react_1.useCallback)((row, col, char) => {
        const cell = getCellData(row, col);
        if (!cell.used) {
          throw new Error("unexpected setCellCharacter call");
        }
        if (cell.guess === char) {
          return;
        }
        setGridData((0, immer_1.default)((draft) => {
          draft[row][col].guess = char;
        }));
        setCheckQueue((0, immer_1.default)((draft) => {
          draft.push({ row, col });
        }));
        if (onCellChange) {
          onCellChange(row, col, char);
        }
      }, [getCellData, onCellChange]);
      const notifyAnswerComplete = (0, react_1.useCallback)((direction, number, correct, answer) => {
        if (onAnswerComplete) {
          onAnswerComplete(direction, number, correct, answer);
        }
        if (correct) {
          if (onAnswerCorrect) {
            onAnswerCorrect(direction, number, answer);
          }
          if (onCorrect) {
            onCorrect(direction, number, answer);
          }
        } else if (onAnswerIncorrect) {
          onAnswerIncorrect(direction, number, answer);
        }
      }, [onAnswerComplete, onAnswerCorrect, onAnswerIncorrect, onCorrect]);
      const checkCorrectness = (0, react_1.useCallback)((row, col) => {
        const cell = getCellData(row, col);
        if (!cell.used) {
          throw new Error("unexpected unused cell");
        }
        util_1.bothDirections.forEach((direction) => {
          const across = (0, util_1.isAcross)(direction);
          const number = cell[direction];
          if (!number) {
            return;
          }
          const info = data[direction][number];
          let complete = true;
          let correct = true;
          for (let i2 = 0; i2 < info.answer.length; i2++) {
            const checkCell = getCellData(info.row + (across ? 0 : i2), info.col + (across ? i2 : 0));
            if (!checkCell.guess) {
              complete = false;
              correct = false;
              break;
            }
            if (checkCell.guess !== checkCell.answer) {
              correct = false;
            }
          }
          setClues((0, immer_1.default)((draft) => {
            if (draft) {
              const clueInfo = draft[direction].find((i2) => i2.number === number);
              if (clueInfo) {
                clueInfo.complete = complete;
                clueInfo.correct = correct;
              }
            }
          }));
          if (complete) {
            notifyAnswerComplete(direction, number, correct, info.answer);
          }
        });
      }, [data, getCellData, notifyAnswerComplete]);
      (0, react_1.useEffect)(() => {
        if (checkQueue.length === 0) {
          return;
        }
        checkQueue.forEach(({ row, col }) => checkCorrectness(row, col));
        setCheckQueue([]);
      }, [checkQueue, checkCorrectness]);
      const { crosswordComplete, crosswordCorrect } = (0, react_1.useMemo)(() => {
        const complete = !!(clues && util_1.bothDirections.every((direction) => clues[direction].every((clueInfo) => clueInfo.complete)));
        const correct = complete && !!(clues && util_1.bothDirections.every((direction) => clues[direction].every((clueInfo) => clueInfo.correct)));
        return { crosswordComplete: complete, crosswordCorrect: correct };
      }, [clues]);
      (0, react_1.useEffect)(() => {
        if (crosswordComplete) {
          if (onCrosswordComplete) {
            onCrosswordComplete(crosswordCorrect);
          }
          if (onCrosswordCorrect) {
            onCrosswordCorrect(crosswordCorrect);
          }
        }
      }, [
        crosswordComplete,
        crosswordCorrect,
        onCrosswordComplete,
        onCrosswordCorrect
      ]);
      const focus = (0, react_1.useCallback)(() => {
        if (registeredFocusHandler.current) {
          registeredFocusHandler.current();
          setFocused(true);
        } else {
          console.warn("CrosswordProvider: focus() has no registered handler to call!");
        }
      }, []);
      const moveTo = (0, react_1.useCallback)((row, col, directionOverride) => {
        var _a;
        let direction = directionOverride !== null && directionOverride !== void 0 ? directionOverride : currentDirection;
        const candidate = getCellData(row, col);
        if (!candidate.used) {
          return false;
        }
        if (!candidate[direction]) {
          direction = (0, util_1.otherDirection)(direction);
        }
        setFocusedRow(row);
        setFocusedCol(col);
        setCurrentDirection(direction);
        setCurrentNumber((_a = candidate[direction]) !== null && _a !== void 0 ? _a : "");
        return candidate;
      }, [currentDirection, getCellData]);
      const moveRelative = (0, react_1.useCallback)((dRow, dCol) => {
        let direction;
        if (dRow !== 0 && dCol === 0) {
          direction = "down";
        } else if (dRow === 0 && dCol !== 0) {
          direction = "across";
        }
        const cell = moveTo(focusedRow + dRow, focusedCol + dCol, direction);
        return cell;
      }, [focusedRow, focusedCol, moveTo]);
      const moveForward = (0, react_1.useCallback)(() => {
        const across = (0, util_1.isAcross)(currentDirection);
        moveRelative(across ? 0 : 1, across ? 1 : 0);
      }, [currentDirection, moveRelative]);
      const moveBackward = (0, react_1.useCallback)(() => {
        const across = (0, util_1.isAcross)(currentDirection);
        moveRelative(across ? 0 : -1, across ? -1 : 0);
      }, [currentDirection, moveRelative]);
      const handleSingleCharacter = (0, react_1.useCallback)((char) => {
        setCellCharacter(focusedRow, focusedCol, char.toUpperCase());
        moveForward();
      }, [focusedRow, focusedCol, setCellCharacter, moveForward]);
      const handleInputKeyDown = (0, react_1.useCallback)((event) => {
        var _a;
        if (event.ctrlKey || event.altKey || event.metaKey) {
          return;
        }
        let preventDefault = true;
        const { key } = event;
        switch (key) {
          case "ArrowUp":
            moveRelative(-1, 0);
            break;
          case "ArrowDown":
            moveRelative(1, 0);
            break;
          case "ArrowLeft":
            moveRelative(0, -1);
            break;
          case "ArrowRight":
            moveRelative(0, 1);
            break;
          case " ":
          case "Tab": {
            const other = (0, util_1.otherDirection)(currentDirection);
            const cellData = getCellData(focusedRow, focusedCol);
            if (cellData[other]) {
              setCurrentDirection(other);
              setCurrentNumber((_a = cellData[other]) !== null && _a !== void 0 ? _a : "");
            }
            break;
          }
          case "Backspace":
          case "Delete": {
            setCellCharacter(focusedRow, focusedCol, "");
            if (key === "Backspace") {
              moveBackward();
            }
            break;
          }
          case "Home":
          case "End": {
            const info = data[currentDirection][currentNumber];
            const { answer: { length } } = info;
            let { row, col } = info;
            if (key === "End") {
              const across = (0, util_1.isAcross)(currentDirection);
              if (across) {
                col += length - 1;
              } else {
                row += length - 1;
              }
            }
            moveTo(row, col);
            break;
          }
          default:
            if (key.length !== 1) {
              preventDefault = false;
              break;
            }
            handleSingleCharacter(key);
            break;
        }
        if (preventDefault) {
          event.preventDefault();
        }
      }, [
        moveRelative,
        handleSingleCharacter,
        currentDirection,
        getCellData,
        focusedRow,
        focusedCol,
        setCellCharacter,
        moveBackward,
        data,
        currentNumber,
        moveTo
      ]);
      const handleInputChange = (0, react_1.useCallback)((event) => {
        event.preventDefault();
        setBulkChange(event.target.value);
      }, []);
      (0, react_1.useEffect)(() => {
        if (!bulkChange) {
          return;
        }
        handleSingleCharacter(bulkChange[0]);
        setBulkChange(bulkChange.length === 1 ? null : bulkChange.substring(1));
      }, [bulkChange, handleSingleCharacter]);
      (0, react_1.useEffect)(() => {
        const newGridData = masterGridData.map((row) => row.map((cell) => Object.assign({}, cell)));
        const newCluesData = {
          across: masterClues.across.map((clue) => Object.assign({}, clue)),
          down: masterClues.down.map((clue) => Object.assign({}, clue))
        };
        if (useStorage) {
          (0, util_1.loadGuesses)(newGridData, storageKey || defaultStorageKey);
        }
        setClues(newCluesData);
        setGridData(newGridData);
        if (useStorage) {
          setCheckQueue(util_1.bothDirections.flatMap((dir) => (
            // simply use the row/col that starts each answer.
            newCluesData[dir].map(({ row, col }) => ({ row, col }))
          )));
        }
        setFocusedRow(0);
        setFocusedCol(0);
        setCurrentDirection("across");
        setCurrentNumber("1");
      }, [masterClues, masterGridData, storageKey, useStorage]);
      (0, react_1.useEffect)(() => {
        if (gridData === null || !useStorage) {
          return;
        }
        (0, util_1.saveGuesses)(gridData, storageKey || defaultStorageKey);
      }, [gridData, storageKey, useStorage]);
      const handleCellClick = (0, react_1.useCallback)((cellData) => {
        var _a;
        if (cellData.used) {
          const { row, col } = cellData;
          const other = (0, util_1.otherDirection)(currentDirection);
          setFocusedRow(row);
          setFocusedCol(col);
          let direction = currentDirection;
          if (!cellData[currentDirection] || focused && row === focusedRow && col === focusedCol && cellData[other]) {
            setCurrentDirection(other);
            direction = other;
          }
          setCurrentNumber((_a = cellData[direction]) !== null && _a !== void 0 ? _a : "");
        }
        focus();
      }, [currentDirection, focus, focused, focusedCol, focusedRow]);
      const handleInputClick = (0, react_1.useCallback)(() => {
        var _a;
        const other = (0, util_1.otherDirection)(currentDirection);
        const cellData = getCellData(focusedRow, focusedCol);
        let direction = currentDirection;
        if (focused && cellData[other]) {
          setCurrentDirection(other);
          direction = other;
        }
        setCurrentNumber((_a = cellData[direction]) !== null && _a !== void 0 ? _a : "");
        focus();
      }, [currentDirection, focus, focused, focusedCol, focusedRow, getCellData]);
      const handleClueSelected = (0, react_1.useCallback)((direction, number) => {
        const info = clues === null || clues === void 0 ? void 0 : clues[direction].find((clue) => clue.number === number);
        if (!info) {
          return;
        }
        moveTo(info.row, info.col, direction);
        focus();
        if (onClueSelected) {
          onClueSelected(direction, number);
        }
      }, [clues, focus, moveTo, onClueSelected]);
      const registerFocusHandler = (0, react_1.useCallback)((focusHandler) => {
        registeredFocusHandler.current = focusHandler;
      }, []);
      (0, react_1.useImperativeHandle)(ref, () => ({
        /**
         * Sets focus to the crossword component.
         */
        focus,
        /**
         * Resets the entire crossword; clearing all answers in the grid and
         * also any persisted data.
         */
        reset: () => {
          setGridData((0, immer_1.default)((draft) => {
            draft.forEach((rowData) => {
              rowData.forEach((cellData) => {
                if (cellData.used) {
                  cellData.guess = "";
                }
              });
            });
          }));
          setClues((0, immer_1.default)((draft) => {
            util_1.bothDirections.forEach((direction) => {
              var _a;
              (_a = draft === null || draft === void 0 ? void 0 : draft[direction]) === null || _a === void 0 ? void 0 : _a.forEach((clueInfo) => {
                delete clueInfo.complete;
                delete clueInfo.correct;
              });
            });
          }));
          if (useStorage) {
            (0, util_1.clearGuesses)(storageKey || defaultStorageKey);
          }
        },
        /**
         * Fills all the answers in the grid and calls the `onLoadedCorrect`
         * callback with _**every**_ answer.
         */
        fillAllAnswers: () => {
          setGridData((0, immer_1.default)((draft) => {
            draft.forEach((rowData) => {
              rowData.forEach((cellData) => {
                if (cellData.used) {
                  cellData.guess = cellData.answer;
                }
              });
            });
          }));
          setClues((0, immer_1.default)((draft) => {
            util_1.bothDirections.forEach((direction) => {
              draft === null || draft === void 0 ? void 0 : draft[direction].forEach((clueInfo) => {
                clueInfo.complete = true;
                clueInfo.correct = true;
              });
            });
          }));
          if (onLoadedCorrect) {
            const loadedCorrect = [];
            util_1.bothDirections.forEach((direction) => {
              clues === null || clues === void 0 ? void 0 : clues[direction].forEach(({ number, answer }) => {
                loadedCorrect.push([direction, number, answer]);
              });
            });
            onLoadedCorrect(loadedCorrect);
          }
        },
        /**
         * Returns whether the crossword is entirely correct or not.
         */
        isCrosswordCorrect: () => crosswordCorrect,
        /**
         * Sets the guess character for a specific grid position.
         *
         * @since 4.1.0
         */
        setGuess: (row, col, guess) => {
          setCellCharacter(row, col, guess.toUpperCase());
        }
      }), [
        clues,
        crosswordCorrect,
        focus,
        onLoadedCorrect,
        setCellCharacter,
        storageKey,
        useStorage
      ]);
      const crosswordContext = (0, react_1.useMemo)(() => ({
        rows,
        cols,
        gridData,
        clues,
        handleInputKeyDown,
        handleInputChange,
        handleCellClick,
        handleInputClick,
        handleClueSelected,
        registerFocusHandler,
        focused,
        selectedPosition: { row: focusedRow, col: focusedCol },
        selectedDirection: currentDirection,
        selectedNumber: currentNumber,
        crosswordCorrect
      }), [
        rows,
        cols,
        gridData,
        clues,
        handleInputKeyDown,
        handleInputChange,
        handleCellClick,
        handleInputClick,
        handleClueSelected,
        registerFocusHandler,
        focused,
        focusedRow,
        focusedCol,
        currentDirection,
        currentNumber,
        crosswordCorrect
      ]);
      return (0, jsx_runtime_1.jsx)(styled_components_1.ThemeProvider, Object.assign({ theme: finalTheme }, { children: (0, jsx_runtime_1.jsx)(context_1.CrosswordContext.Provider, Object.assign({ value: crosswordContext }, { children })) }));
    });
    exports.default = CrosswordProvider;
    CrosswordProvider.displayName = "CrosswordProvider";
    CrosswordProvider.propTypes = exports.crosswordProviderPropTypes;
    CrosswordProvider.defaultProps = {
      theme: void 0,
      useStorage: true,
      storageKey: void 0,
      onAnswerComplete: void 0,
      onAnswerCorrect: void 0,
      onCorrect: void 0,
      onAnswerIncorrect: void 0,
      onLoadedCorrect: void 0,
      onCrosswordComplete: void 0,
      onCrosswordCorrect: void 0,
      onCellChange: void 0,
      onClueSelected: void 0,
      children: void 0
    };
  }
});

// node_modules/@jaredreisinger/react-crossword/dist/CrosswordGrid.js
var require_CrosswordGrid = __commonJS({
  "node_modules/@jaredreisinger/react-crossword/dist/CrosswordGrid.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var prop_types_1 = __importDefault(require_prop_types());
    var styled_components_1 = __importStar((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var Cell_1 = __importDefault(require_Cell());
    var context_1 = require_context();
    var defaultTheme = {
      columnBreakpoint: "768px",
      gridBackground: "rgb(0,0,0)",
      cellBackground: "rgb(255,255,255)",
      cellBorder: "rgb(0,0,0)",
      textColor: "rgb(0,0,0)",
      numberColor: "rgba(0,0,0, 0.25)",
      focusBackground: "rgb(255,255,0)",
      highlightBackground: "rgb(255,255,204)"
    };
    var GridWrapper = styled_components_1.default.div.attrs(() => ({
      className: "crossword grid"
    }))`
  /* position: relative; */
  /* min-width: 20rem; */
  /* max-width: 60rem; Should the size matter? */
  width: auto;
  flex: 2 1 50%;
`;
    var CrosswordGridPropTypes = {
      /** presentation values for the crossword; these override any values coming from a parent ThemeProvider context. */
      theme: prop_types_1.default.shape({
        /** browser-width at which the clues go from showing beneath the grid to showing beside the grid */
        columnBreakpoint: prop_types_1.default.string,
        /** overall background color (fill) for the crossword grid; can be `'transparent'` to show through a page background image */
        gridBackground: prop_types_1.default.string,
        /**  background for an answer cell */
        cellBackground: prop_types_1.default.string,
        /** border for an answer cell */
        cellBorder: prop_types_1.default.string,
        /** color for answer text (entered by the player) */
        textColor: prop_types_1.default.string,
        /** color for the across/down numbers in the grid */
        numberColor: prop_types_1.default.string,
        /** background color for the cell with focus, the one that the player is typing into */
        focusBackground: prop_types_1.default.string,
        /** background color for the cells in the answer the player is working on,
         * helps indicate in which direction focus will be moving; also used as a
         * background on the active clue  */
        highlightBackground: prop_types_1.default.string
      })
    };
    function CrosswordGrid({ theme }) {
      const { rows, cols, gridData, handleInputKeyDown, handleInputChange, handleCellClick, handleInputClick, registerFocusHandler, focused, selectedPosition: { row: focusedRow, col: focusedCol }, selectedDirection: currentDirection, selectedNumber: currentNumber } = (0, react_1.useContext)(context_1.CrosswordContext);
      const inputRef = (0, react_1.useRef)(null);
      const contextTheme = (0, react_1.useContext)(styled_components_1.ThemeContext);
      const focus = (0, react_1.useCallback)(() => {
        var _a;
        (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
      }, []);
      (0, react_1.useEffect)(() => {
        registerFocusHandler(focus);
        return () => {
          registerFocusHandler(null);
        };
      }, [focus, registerFocusHandler]);
      const cellSize = 10;
      const cellPadding = 0.125;
      const cellInner = cellSize - cellPadding * 2;
      const cellHalf = cellSize / 2;
      const fontSize = cellInner * 0.7;
      const sizeContext = (0, react_1.useMemo)(() => ({
        cellSize,
        cellPadding,
        cellInner,
        cellHalf,
        fontSize
      }), [cellSize, cellPadding, cellInner, cellHalf, fontSize]);
      const height = (0, react_1.useMemo)(() => rows * cellSize, [rows]);
      const width = (0, react_1.useMemo)(() => cols * cellSize, [cols]);
      const cellWidthHtmlPct = (0, react_1.useMemo)(() => 100 / cols, [cols]);
      const cellHeightHtmlPct = (0, react_1.useMemo)(() => 100 / rows, [rows]);
      const inputStyle = (0, react_1.useMemo)(() => ({
        position: "absolute",
        top: `calc(${focusedRow * cellHeightHtmlPct * 0.995}% + 2px)`,
        left: `calc(${focusedCol * cellWidthHtmlPct}% + 2px)`,
        width: `calc(${cellWidthHtmlPct}% - 4px)`,
        height: `calc(${cellHeightHtmlPct}% - 4px)`,
        fontSize: `${fontSize * 6}px`,
        textAlign: "center",
        textAnchor: "middle",
        backgroundColor: "transparent",
        caretColor: "transparent",
        margin: 0,
        padding: 0,
        border: 0,
        cursor: "default"
      }), [cellWidthHtmlPct, cellHeightHtmlPct, focusedRow, focusedCol, fontSize]);
      const finalTheme = (0, react_1.useMemo)(() => Object.assign(Object.assign(Object.assign({}, defaultTheme), contextTheme), theme), [contextTheme, theme]);
      return (0, jsx_runtime_1.jsx)(context_1.CrosswordSizeContext.Provider, Object.assign({ value: sizeContext }, { children: (0, jsx_runtime_1.jsx)(styled_components_1.ThemeProvider, Object.assign({ theme: finalTheme }, { children: (0, jsx_runtime_1.jsx)(GridWrapper, { children: (0, jsx_runtime_1.jsxs)("div", Object.assign({ style: { margin: 0, padding: 0, position: "relative" } }, { children: [(0, jsx_runtime_1.jsxs)("svg", Object.assign({ viewBox: `0 0 ${width} ${height}` }, { children: [(0, jsx_runtime_1.jsx)("rect", { x: 0, y: 0, width, height, fill: finalTheme.gridBackground }), gridData.flatMap((rowData, row) => rowData.map((cellData, col) => cellData.used ? (
        // Should the Cell figure out its focus/highlight state
        // directly from the CrosswordContext?
        (0, jsx_runtime_1.jsx)(
          Cell_1.default,
          { cellData, focus: focused && row === focusedRow && col === focusedCol, highlight: focused && !!currentNumber && cellData[currentDirection] === currentNumber, onClick: handleCellClick },
          `R${row}C${col}`
        )
      ) : void 0))] })), (0, jsx_runtime_1.jsx)("input", {
        ref: inputRef,
        "aria-label": "crossword-input",
        type: "text",
        onClick: handleInputClick,
        onKeyDown: handleInputKeyDown,
        onChange: handleInputChange,
        value: "",
        // onInput={this.handleInput}
        autoComplete: "off",
        spellCheck: "false",
        autoCorrect: "off",
        style: inputStyle
      })] })) }) })) }));
    }
    exports.default = CrosswordGrid;
    CrosswordGrid.propTypes = CrosswordGridPropTypes;
    CrosswordGrid.defaultProps = {
      theme: null
    };
  }
});

// node_modules/@jaredreisinger/react-crossword/dist/Crossword.js
var require_Crossword = __commonJS({
  "node_modules/@jaredreisinger/react-crossword/dist/Crossword.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __rest = exports && exports.__rest || function(s2, e2) {
      var t2 = {};
      for (var p in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
          t2[p] = s2[p];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s2); i2 < p.length; i2++) {
          if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i2]))
            t2[p[i2]] = s2[p[i2]];
        }
      return t2;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = __importStar(require_react());
    var prop_types_1 = __importDefault(require_prop_types());
    var styled_components_1 = __importDefault((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var CrosswordProvider_1 = __importStar(require_CrosswordProvider());
    var CrosswordGrid_1 = __importDefault(require_CrosswordGrid());
    var DirectionClues_1 = __importDefault(require_DirectionClues());
    var CluesWrapper = styled_components_1.default.div.attrs(() => ({
      className: "clues"
    }))`
  padding: 0 1em;
  flex: 1 2 25%;

  @media (max-width: ${(props) => props.theme.columnBreakpoint}) {
    margin-top: 2em;
  }

  .direction {
    margin-bottom: 2em;
    /* padding: 0 1em;
    flex: 1 1 20%; */

    .header {
      margin-top: 0;
      margin-bottom: 0.5em;
    }

    div {
      margin-top: 0.5em;
    }
  }
`;
    var crosswordPropTypes = Object.assign(Object.assign({}, CrosswordProvider_1.crosswordProviderPropTypes), {
      /** the label for the "across" clues */
      acrossLabel: prop_types_1.default.string,
      /** the label for the "down" clues */
      downLabel: prop_types_1.default.string
    });
    delete crosswordPropTypes.children;
    var Crossword = react_1.default.forwardRef((_a, ref) => {
      var { acrossLabel, downLabel } = _a, props = __rest(_a, ["acrossLabel", "downLabel"]);
      const providerRef = (0, react_1.useRef)(null);
      (0, react_1.useImperativeHandle)(ref, () => ({
        /**
         * Sets focus to the crossword component.
         */
        focus: () => {
          var _a2;
          return (_a2 = providerRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
        },
        /**
         * Resets the entire crossword; clearing all answers in the grid and
         * also any persisted data.
         */
        reset: () => {
          var _a2;
          return (_a2 = providerRef.current) === null || _a2 === void 0 ? void 0 : _a2.reset();
        },
        /**
         * Fills all the answers in the grid and calls the `onLoadedCorrect`
         * callback with _**every**_ answer.
         */
        fillAllAnswers: () => {
          var _a2;
          return (_a2 = providerRef.current) === null || _a2 === void 0 ? void 0 : _a2.fillAllAnswers();
        },
        /**
         * Returns whether the crossword is entirely correct or not.
         *
         * @since 2.2.0
         */
        isCrosswordCorrect: () => {
          var _a2;
          return !!((_a2 = providerRef.current) === null || _a2 === void 0 ? void 0 : _a2.isCrosswordCorrect());
        },
        /**
         * Sets the guess character for a specific grid position.
         *
         * @since 4.1.0
         */
        setGuess: (row, col, guess) => {
          var _a2;
          return (_a2 = providerRef.current) === null || _a2 === void 0 ? void 0 : _a2.setGuess(row, col, guess);
        }
      }), []);
      return (0, jsx_runtime_1.jsxs)(CrosswordProvider_1.default, Object.assign({}, props, { ref: providerRef }, { children: [(0, jsx_runtime_1.jsx)(CrosswordGrid_1.default, {}), (0, jsx_runtime_1.jsxs)(CluesWrapper, { children: [(0, jsx_runtime_1.jsx)(DirectionClues_1.default, { direction: "across", label: acrossLabel }), (0, jsx_runtime_1.jsx)(DirectionClues_1.default, { direction: "down", label: downLabel })] })] }));
    });
    Crossword.displayName = "Crossword";
    Crossword.propTypes = crosswordPropTypes;
    Crossword.defaultProps = Object.assign(Object.assign({}, CrosswordProvider_1.default.defaultProps), { acrossLabel: void 0, downLabel: void 0 });
    exports.default = Crossword;
  }
});

// node_modules/@jaredreisinger/react-crossword/dist/ipuz.js
var require_ipuz = __commonJS({
  "node_modules/@jaredreisinger/react-crossword/dist/ipuz.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertIpuz = exports.isSupportedIpuz = exports.isIpuzData = exports.useIpuz = void 0;
    var react_1 = require_react();
    var IpuzURI = "http://ipuz.org";
    var IpuzVersionURI = `${IpuzURI}/v`;
    var IpuzVersion = 2;
    var IpuzCrosswordURI = `${IpuzURI}/crossword#`;
    var IpuzCrosswordVersion = 1;
    var directionMap = {
      Across: "across",
      Down: "down"
    };
    function useIpuz(data) {
      return (0, react_1.useMemo)(() => {
        if (!isIpuzData(data)) {
          console.error("useIpuz() was not given IPUZ data");
          return null;
        }
        if (!isSupportedIpuz(data)) {
          console.error("useIpuz() was not given supported IPUZ data");
          return null;
        }
        return convertIpuz(data);
      }, [data]);
    }
    exports.useIpuz = useIpuz;
    function isIpuzData(data) {
      return !!data && typeof data === "object" && "version" in data && typeof data.version === "string" && data.version.startsWith(IpuzVersionURI);
    }
    exports.isIpuzData = isIpuzData;
    function isSupportedIpuz(ipuz) {
      const version = Number.parseInt(ipuz.version.substring(IpuzVersionURI.length), 10);
      if (version > IpuzVersion) {
        return false;
      }
      if (ipuz.kind.length !== 1 || !ipuz.kind[0].startsWith(IpuzCrosswordURI)) {
        return false;
      }
      const crosswordVersion = Number.parseInt(ipuz.kind[0].substring(IpuzCrosswordURI.length), 10);
      if (crosswordVersion > IpuzCrosswordVersion) {
        return false;
      }
      return true;
    }
    exports.isSupportedIpuz = isSupportedIpuz;
    function convertIpuz(ipuz) {
      const clueLocs = ipuz.puzzle.reduce((memoOuter, rowData, row) => rowData.reduce((memoInner, cell, col) => {
        var _a;
        const key = typeof cell === "object" ? (_a = cell === null || cell === void 0 ? void 0 : cell.cell) !== null && _a !== void 0 ? _a : -1 : cell;
        memoInner[key.toString()] = { row, col };
        return memoInner;
      }, memoOuter), {});
      const converted = Object.fromEntries(Object.entries(ipuz.clues).map(([dir, clueList]) => {
        const dirClues = clueList.reduce((memo, [num, clueText]) => {
          const { row, col } = clueLocs[num.toString()];
          let answer = "";
          const dr = dir === "Across" ? 0 : 1;
          const dc = dir === "Across" ? 1 : 0;
          for (let r2 = row, c2 = col; r2 < ipuz.dimensions.height && c2 < ipuz.dimensions.width; r2 += dr, c2 += dc) {
            const ch = ipuz.solution[r2][c2];
            if (!ch || ch === "#") {
              break;
            }
            answer += ch;
          }
          memo[num.toString()] = {
            clue: clueText,
            answer,
            row,
            col
          };
          return memo;
        }, {});
        return [directionMap[dir], dirClues];
      }));
      return converted;
    }
    exports.convertIpuz = convertIpuz;
  }
});

// node_modules/@jaredreisinger/react-crossword/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@jaredreisinger/react-crossword/dist/index.js"(exports) {
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useIpuz = exports.ThemeProvider = exports.CrosswordSizeContext = exports.CrosswordContext = exports.CrosswordProvider = exports.CrosswordGrid = exports.Crossword = exports.DirectionClues = exports.Clue = exports.Cell = void 0;
    var styled_components_1 = (init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports));
    Object.defineProperty(exports, "ThemeProvider", { enumerable: true, get: function() {
      return styled_components_1.ThemeProvider;
    } });
    var Cell_1 = __importDefault(require_Cell());
    exports.Cell = Cell_1.default;
    var Clue_1 = __importDefault(require_Clue());
    exports.Clue = Clue_1.default;
    var DirectionClues_1 = __importDefault(require_DirectionClues());
    exports.DirectionClues = DirectionClues_1.default;
    var Crossword_1 = __importDefault(require_Crossword());
    exports.Crossword = Crossword_1.default;
    var CrosswordGrid_1 = __importDefault(require_CrosswordGrid());
    exports.CrosswordGrid = CrosswordGrid_1.default;
    var CrosswordProvider_1 = __importDefault(require_CrosswordProvider());
    exports.CrosswordProvider = CrosswordProvider_1.default;
    var context_1 = require_context();
    Object.defineProperty(exports, "CrosswordContext", { enumerable: true, get: function() {
      return context_1.CrosswordContext;
    } });
    Object.defineProperty(exports, "CrosswordSizeContext", { enumerable: true, get: function() {
      return context_1.CrosswordSizeContext;
    } });
    var ipuz_1 = require_ipuz();
    Object.defineProperty(exports, "useIpuz", { enumerable: true, get: function() {
      return ipuz_1.useIpuz;
    } });
    exports.default = Crossword_1.default;
  }
});
export default require_dist2();
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@jaredreisinger_react-crossword.js.map
